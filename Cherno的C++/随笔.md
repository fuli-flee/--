[toc]
***
# Lecture 19 类与结构体
- class和struct之间只有一种区别: 默认情况下,类是私有的,结构体是公有的
</br>

- struct用于纯数据结构，即只有公有数据成员，没有或很少有成员函数。
- class用于需要数据封装和抽象的“真正的对象”。当类中有私有成员、复杂的成员函数、继承和多态时，几乎总是使用 class。
</br>

- struct在C++继续存在的唯一原因是因为它希望与C保持向后兼容性,因为C有struct却没有class
- 如果要有一个完整的类层次结构,或者某种继承层次结构,最好用类
- 用struct自定义变量集合,用class来定义功能的逻辑抽象(C++并没有规定一定要这样,这是约定俗成的)
***
# Lecture 28 虚函数
- 我们通常在声明函数时,我们的方法通常在类的内部起作用,然后当要调用的方法的时候,会调用属于该类型的方法,所以以下代码会打印出两次Entity
```cpp
#include<iostream>
#include<string>

class Entity
{
public:
	std::string GetName() { return "Entity"; }
};

class Player : public Entity
{
private:
	std::string m_Name;
public:
	Player(const std::string& name)
		:m_Name(name){}

	std::string GetName() { return m_Name; }
};

void PrintName(Entity* entity)
{
	std::cout << entity->GetName() << std::endl;
}

int main()
{
	Entity* e = new Entity();
	PrintName(e);

	Player* p = new Player("Cherno");
	PrintName(p);

	std::cin.get();
}
```
- 虚函数引入了动态联编,它通常通过虚函数表来实现编译,虚函数表包含基类中所有虚函数的映射,这样我们可以在它运行时,将它们映射到正确的override函数
- 如果你想override一个函数,就必须将基类的基函数标记为虚函数
- 虚函数有两个成本需要考虑: 
  - 我们需要额外的内存来存储虚函数表,包括基类中要有一个成员指针指向虚函数表
  - 每次我们调用虚函数时,我们需要遍历虚函数表,来确定映射到那个函数
***
# Lecture 34 Const
- 它是声明一个变量的一种方式,告诉编译器,我不会去修改它
## 指针常量和常量指针
```cpp
const int* a = new int;

*a = 2;//这样写会报错
```
- 这意味着你不能修改该指针的指向内容
```cpp
int* const a = new int;

a = nullptr; //这样写会报错
```
- 这意味着可以改变指针指向的内容,但不能把实际的指针本身赋值

## 修饰方法
- 在函数的参数列表后加上const,这只在类中有效,这不会修改任何实际的类,所以不能修改类成员变量
- 当你在类外声明函数并传递类的const实例时,你无法调用类的非const的成员函数(很抽象,我知道,看下面例子)
```cpp
class Entity
{
private:
	int m_X, m_Y;
public:
	int GetX() 
	{
		m_X = 2;
		return m_X;
	}
};

void PrintEntity(const Entity& e) //因为这里定义了const
{
	std::cout << e.GetX() << std::endl;//所以当遇到能改变实例e的值的函数会报错
}
```
***
# lecture 40 隐式转换和explicit
- 隐式转换只能转换一次
- explicit 会禁用隐式转换，explicit关键字放在构造函数前面
- 所以explicit用来当你想要显式的调用构造函数

***
# Lecture 41 操作符及其重载
- new和delete是操作符
- 逗号，方括号，圆括号等都是操作符
- 操作符只是函数

*** 
# Lecture 42 this关键字
- 通过this关键字，可以访问成员函数
- this是指向当前对象的指针

***
# Lecture 43 对象的生命周期
- 基于栈的变量在离开作用域的时候会被摧毁，内存会释放
- unique_ptr能使指针在跳出作用域时自动删除它
***
# Lecture 44 智能指针
- new用来在堆上分配内存，而delete用来删除对象和释放内存，因为new分配的内存不会自动释放
- 智能指针就是对原始指针的包装，当你创建一个智能指针，它会调用new为你分配内存，然后基于你的智能指针，分配的内存会在某一时刻自动释放
  
## unique_ptr：作用域指针
- 当这个指针超出作用域时，它就会被销毁，就会调用delete
- unique_ptr必须是唯一的，它不能复制另一个unique_ptr，如果复制了一个unique_ptr，那么它们指向的内存，就会出现两个unique_ptr指向相同的内存，当其中一个指针释放了内存，那么另一个指针就会指向一个已经被释放的内存
- 所以unique_ptr适用于你想要一个作用域指针且需要一个唯一引用的指针时

## shared_ptr: 共享型指针
- 内部维护一个引用计数来控制释放
- shared_ptr会额外分配一块叫做控制块的内存，用来存储引用计数

## weak_ptr：弱指针
- 不会增加shared_ptr的引用计数
- 如果不想获得对象的所有权，或者不关心它们是否有效，只需要存储一个引用 
***
# Lecture 45 拷贝和拷贝构造函数
- 在传递对象时一般总会是用const引用去传递对象，因为可以避免拷贝

## 浅拷贝
- 浅拷贝会使拷贝的双方的指针指向相同的地址

## 深拷贝
- 而深拷贝是将整个对象都复制，拷贝双方都拥有独立的内存地址
- 一种方法是创建一个新对象，然后将想要的内容赋值给它；而另一种是利用拷贝构造函数

## 拷贝构造函数
- 拷贝构造函数是一个构造函数，当你复制第二个对象时，它就会被调用
- 当你试图创建一个新的变量并给它分配一个另一个变量时，且这个变量和你正在创建的变量有相同的类型时，你复制这个变量，也就是所谓的拷贝构造函数
- C++默认会提供一个拷贝构造函数

***
# Lecture 46 箭头操作符
```cpp
Entity* ptr = &e;
ptr->Print();  //这句相当于(*ptr).Print();
```
***
# Lecture 47 Vector容器
- Vector扩容,当你加入的元素个数超过当前vector的容量时,会新创建一个比当前容量更大的vector,并将当前vector中的所有元素复制过去,并删除原先的vector

***
# Lecture 48 Vector优化
```cpp
#include<iostream>
#include<vector>

struct Vertex
{
	float x, y, z;

	Vertex()
		:x(0), y(0), z(0)
	{
	}

	Vertex(float x, float y, float z)
		:x(x), y(y), z(z)
	{
	}

	Vertex(const Vertex& vertex)
		:x(vertex.x), y(vertex.y), z(vertex.z)
	{
		std::cout << "Coied!" << std::endl;
	}
};

int main()
{
	std::vector<Vertex>verties;
	verties.push_back({1,2,3});
	verties.push_back({4,5,6});
	verties.push_back({7,8,9});

	std::cin.get();
}
```
- 首先要理解vector中的元素是在堆内存上的,所以当执行这句时
  ```
  verties.push_back({1,2,3});
  ```
  是在主函数的栈帧上先生成一个临时的Vertex对象,然后push_back函数发现verties的容量为0,所以会计算新容量,后在堆上分配一块能容纳1个Vertex对象 的连续内存,后更新verties的容量,最后拷贝临时对象到堆内存（触发拷贝构造）,最后的最后销毁临时对象

- 理解以上流程后,我们易得两个优化的问题:
     1. 为什么不直接在vector的堆内存上构造对象呢?这样不就省得拷贝了吗?
     2. 为什么不预先分配需要的内存空间呢?这样在扩容的时候就不会再去找寻新的空间了?
- 针对以上两个问题
     1. 我们只是想要足够的内存来容纳它,所以做法就是
        ```cpp
        verties.reserve(3);//分配3个vertex对象的空间
        ```
        但是我们平时在刷题的时候通常会遇到这么写的
        ```cpp
        std::vector<Vertex>verties(3);
        ```
        它实际上会构造三个verterx对象,而reserve只是分配出来空间
    
    2. 我们想在实际的vector里构造,而不是通过临时对象后push_back,所以做法是将push_back改为emplace_back
        ```cpp
        verties.emplace_back(1,2,3);
        ```
        这样我们传递的就不是一个已经构造好的vertex对象,我们只是传递了构造函数的参数列表,让vector在实际的堆内存中使用以上参数,构造一个vertex对象

***
# Lecture 49 静态链接 
- 库通常有两部分,include(包含目录)和library
- include目录是一堆头文件,这样我们就可以实际使用预构建的二进制文件中的函数
- library目录有那些预先构建的二进制文件,通常有两个部分,动态库和静态库
- 静态链接意味着这个库会被放到你的可执行文件中,在你的exe文件中
- 动态链接是在运行时被链接,意思就是说你可以选择在程序运行的时候,装载一些动态链接库,通过函数的API载入你的动态库,然后从中拉出函数,开始调用
- dll是一种运行时动态链接库 
***
# Lecture 52 处理多返回值
1. 提前声明需要的值,然后传入函数的参数列表
2. 函数返回值用一个数组来存储
3. 将需要的值事先封装为结构体
4. 利用tuple(元组)
5. 利用pair

## 元组
`std::tuple`本质上是一个类模版,但在取其中元素时不易看出要取的类型,以取第1个元素为例`std::get<0>(元组名)`

## pair
`std::pair`存一对元素,如`pair<int ,string> pa`,当要取其中的int元素时为`pa.first`

- 以上都不不能明显的知道变量是什么,但是用struct就能很清楚的知道
***
# Lecture 53 templates(模版)
- 所谓模版,就是让编译器为你写代码,基于你给编译器的规则 
```cpp
template<typename T> //typename作为模版参数的类型    T作为名字
void Print(T value)
{
	std::cout << value << std::endl;
}
```
- 定义的模版T在编译的时候就被评估,而用模版写的函数Print不是一个真正的函数,只有我们实际调用它的时候,这些函数才被真的创建,基于传递的参数,这个函数才被创建出来,并作为源代码被编译
- 在调用时也能显式调用,如:
  ```cpp
  Print<std::string>("Cherno");

  Print(5); //这里为隐式调用,模版类型为int
  ```
- 模版并不是实际存在的,直到我们调用它,所以你在写模版函数的时候,语法出错或异常的情况下编译也是可行的,但是运行是肯定会出错的
***
# Lecture 54 堆与栈的内存比较
- 栈和堆是RAM上实际存在的两个区域
- 栈通常是一个预定大小的内存区域,通常为2M字节左右
- 堆也是一个预定义了默认值的区域,但是它可以生长,并随着程序的进行而改变
- 这两个的实际物理位置在RAM中是完全一样的
- 在栈上分配内存就像一条CPU指令,而在堆上分配内存会经历很多 "手续"
- 在堆上分配的唯一原因是,你不能够在栈上分配,比如这个生命周期比函数的作用域更长,或者你特别需要更多的数据;其他的,你应该总是在栈上分配内存

## 栈
- 当我们在栈中分配变量时,其实就是移动栈顶指针相应的内存空间,所以你会看到在代码中紧挨着的栈分配代码,内存也是挨着的,所以其实栈只是把东西堆在一起,所以它快,当代码运行到离开相关作用域时,栈顶指针又会回到刚进入这个作用域是的内存位置

## 堆
- new关键字实际上调用了malloc(memory allocate的缩写)函数,这样通常会调用底层操作系统或平台的特定函数,然后为你在堆上分配内存;具体为,当你启动你的程序时,你会得到一定数量的物理RAM,分配给你,程序会维护一个叫空闲列表的东西,它是跟踪哪些内存块是空闲的,所以当你需要动态堆内存时,它会去浏览空闲列表,找到一个至少和你要的一样大的内存空间,然后给他们一个指针
- 如果你需要的内存超过了空闲列表,超过了你的操作系统给你的初始分配,程序会询问你的操作系统请求更多的内存,这个过程的成本是很大的


***
# Lecture 55 宏
- 当我们编译C++代码时,首先预处理器会过一遍C++所有你看到的语句;预处理以#开头,这是预编译指令符号,当预处理器评估完代码后,再把代码给到编译器进行实际的编译;预处理阶段基本上是一个文本编辑阶段,在这个阶段,我们可以控制什么代码会实际喂给编译器

***
# Lecture 56 auto
- 在类型很大很长的时候用auto
***

# Lecture 57 std::array
***
# Lecture 58 函数指针
- 实际的函数指针类型(即如何定义一个函数指针): `返回值 (* 函数指针名)(参数类型列表)`,

```cpp
#include<iostream>
#include<string>

void HelloWorld(int a,std::string str)
{
	std::cout << "Hello World! valua = "<< a 
              << " " << "string = " 
              << str << std::endl;
}

int main()
{
	void(*function)(int,std::string);//这个就是定义的与HelloWorld函数匹配的函数指针

	function = HelloWorld;

	function(5,"cherno");

	std::cin.get();
}
```

- 当我们有了函数指针的概念后,我们就可以做到,将函数作为参数传入到另一个函数中使用

```cpp
#include<iostream>
#include<vector>

void PrintValue(int value)
{
	std::cout << "Value: " << value << std::endl;
}

void Foreach(const std::vector<int>& nums,void(*Print)(int))
{
	for (auto num : nums)
		Print(num);
}

int main()
{
	std::vector<int> nums = { 1,2,3,4,5,6 };

	Foreach(nums,PrintValue);

	std::cin.get();
}
```
***
# Lecture 59 Lambda表达式(匿名函数)

- lambda表达式就是我们不需要通过函数定义,就可以定义一个函数的方法;一般在需要快速创建一个一次性的函数时使用,使用过程更像是在使用一个变量
- lambda表达式书写格式：
  `[捕获列表] (参数列表) {函数体}`
  1. `[捕获列表]`: 我们想访问lambda外的变量放到这里,有两种方式传递,值传递或引用传递,而方括号就是说我们打算如何传递变量;
      - `[=]`: 通过值传递传递所有的变量
      - `[&]`: 通过引用传递传递所有的变量

***
# Lecture 61 命名空间
- 命名空间的主要目的就是避免命名冲突

***
# Lecture 62 线程
- 定义一个线程: `std::thread 线程名( 函数指针 )`;
```cpp
std::thread work(DoWork);
```
- 以上面的例子继续,`work.join()`会让当前线程等待另一线程运行完成,因此会阻塞当前线程,直到另一线程完成,这两线程是并行运行的
- `std::this_thread`可以用它来给当前线程下达命令

***
# Lecture 64 多维数组
- 二维数组
```cpp
int** a2d = new int* [50]; //这里是在分配50个int*指针
```

***
# Lecture 66 类型双关
```cpp
int main()
{
	int a = 50;
	double value = a;

	std::cout << value << std::endl;

	std::cin.get();
}
```

- 这里隐式转换了整型为双精度类型,a在`double value = a;`依然是整型,若想将a的内存从整型指针转换为双精度指针内存(4字节到8字节),如下

```cpp
double value = *(double*)&a;//这里真正的将a从int类型转换为了double
```
- `&a`：获取整数a的地址; `(double*)&a`：将int指针强制转换为double指针; `*(double*)&a`：解引用这个double指针;这不是类型转换，而是内存重新解释！但是在重新解读后多读了4个字节的内存,这本是不属于我们的内存,所以这是不好的
- 即使是一个空的结构体,它也有1个字节的内存占位,因为我们需要对这段内存寻址

***
# Lecture 67 union联合体
```cpp
struct Union
{
	union 
	{
		float a;
		int b;
	};
};

Union u;
u.a = 2.0f;
std::cout << u.a << " , " << u.b << std::endl;
```

- 联合体的所有成员共享同一块内存空间。这意味着：
- u.a和u.b占用相同的内存地址
- 当你给u.a赋值时，实际上是在这块内存中存储了浮点数 2.0 的二进制表示
- 当你读取u.b时，是把同一块内存的二进制数据解释为整数


***
# Lecture 68 虚析构函数 
```cpp
#include<iostream>

class Base
{
public:
	Base() { std::cout << "Base Constructor!\n"; };
	~Base() { std::cout << "Base Destructor!\n"; };
};

class Derived : public Base
{
public:
	Derived() { std::cout << "Derived Constructor!\n"; };
	~Derived() { std::cout << "Derived Destructor!\n"; };
};

int main()
{
	Base* base = new Base();
	delete base;

	std::cout << "---------------------\n";

	Derived* derived = new Derived();
	delete derived;

	std::cout << "---------------------\n";
	Base* poly = new Derived();
	delete poly;

	std::cin.get();
}
```
- 打印输出为
```
Base Constructor!
Base Destructor!
---------------------
Base Constructor!
Derived Constructor!
Derived Destructor!
Base Destructor!
---------------------
Base Constructor!
Derived Constructor!
Base Destructor!
```
- 从结果可以看出,基类指针的派生类实例poly在析构的时候没有调用自己的派生类析构函数,而是只调用了基类的析构函数
</br>

- 因为基类的析构函数没有标记为虚函数,所以C++不知道在层次结构下的某种重写方法
</br>

- 在普通的方法前标记为virtual,那么它就可以被重写,这就意味着要做虚函数表这样的设置;析构函数有点不太一样,虚析构函数的意思,不是重写析构函数,而是加上一个析构函数;所以把基类的析构函数改为虚析构函数,它实际上会调用两个析构函数,它会先调用派生类的析构函数,然后在层次结构中向上,调用基类的析构函数

***
# Lecture 69 C++类型转换
## C语言风格类型转换
```cpp
double value = 5.25;
double a = (int)value + 5.3;

std::cout << a << std::endl;
```
- 这里`(int)value`就进行了类型转换,此时value会将后面的`.25`截掉,此时的`(int)value`值为5
</br>

## C++类型的四种类型转换
- static_cast, reinterpret_cast, dynamic_cast, const_cast
- 以下为dynamic_cast举例
```cpp
#include<iostream>

class Base
{
public:
	Base() {};
	virtual ~Base() {};	
};

class Derived : public Base
{
public:
	Derived() {};
	~Derived() {};
};

class AnotherClass : public Base
{
public:
	AnotherClass() {};
	~AnotherClass() {};
};

int main()
{
	Derived* derived = new Derived();

	Base* base = derived;

	AnotherClass* bc = (AnotherClass*)base;
	AnotherClass* ac = static_cast<AnotherClass*>(base);

	AnotherClass* ac = dynamic_cast<AnotherClass*>(base);

	std::cin.get();
}
```
- 代码中这两句作用差不多
```cpp
AnotherClass* bc = (AnotherClass*)base;
AnotherClass* ac = static_cast<AnotherClass*>(base);
```
- 但是,我们知道base其实是Derived实例,而不是AnotherClass实例,这里经过dynamic_cast后会检查,发现不能安全的类型转换,会将ac置为nullptr
```cpp
AnotherClass* ac = dynamic_cast<AnotherClass*>(base);
```

***
# Lecture 72 预编译头文件
- 它的作用就是接收一堆你告诉它要接收的头文件,它只编译一次,它以二进制格式存储
- 不要将频繁更改的文件放入预编译头文件中
***
# Lecture 73 dynamic_cast
- dynamic_cast是专门用于沿继承层次结构进行的强制类型转换,它更像是一个函数
```cpp
#include<iostream>

class Entity
{
public:
	virtual void PrintName() {}
};

class Player : public Entity
{
};

class Enemy : public Entity
{
};

int main()
{
	Player* player = new Player();
	Entity* e = player;
	Enemy* e1 = new Enemy();

	Player* p = (Player*)e1;
}
```
- 这里的`p`肯定是一个`entity`以及`Player`,但是我们不知道它是不是一个`Enemy`,因为`Player`和`Enemy`无继承关系,所以编译器不知道
</br>

- 而`Player* p = (Player*)e1;`是不安全,`e1`实际上是`Enemy`,如果把它强制转换为`Player`,也不是不可行,前提是`Enemy`有的函数,`Player`和`Entity`也都有的话,我们试着运行这个函数它可能没有问题
</br>

- 但是如果尝试做一些`Enemy`所没有,而`Player`独有的事情,比如`Player`独有的成员变量,程序就可能会崩溃
</br>

```cpp
int main()
{
	Player* player = new Player();
	Entity* actuallyEnemy = new Enemy();
	Entity* actuallyPlayer = player;

	Player* p0 = dynamic_cast<Player*>(actuallyEnemy);
	Player* p1 = dynamic_cast<Player*>(actuallyPlayer);
}
```

- `Player* p0 = dynamic_cast<Player*>(actuallyEnemy);`这一句将会失败,p0会返回NULL
</br>

- 它是怎么知道的? 因为它存储了运行时类型信息(RTTI),这会增加额外开销
- 成本? RTTI增加了开销;dynamic_cast也需要时间,因为我们需要检查类型信息是否匹配

***
# Lecture 76 optional
- `std::optional` 的主要目的就是用来处理那些“可能存在，也可能不存在”的值
```cpp
#include <optional>
std::optional<type> function(param){statement; return type;}
auto result = function();
```
1. result.has_value()判断数据是否存在, 通过result.value()获取数据
2. result.value_or(xxx)其中xxx作为默认值，如果存在数据返回数据，不存在返回xxx
3. 通过if (result)判断数据是否存在

注: 使用场景—目标值可能存在也可能不存在，比如读取文件并返回内容，可能读取成功有数据，读取成功无数据，读取不成功。
***
# Lecture 77 单一变量存放多种类型数据
- `std::variant`的作用是让我们不用担心处理的确切数据类型,先有一个变量,到之后我们再考虑它的具体类型,需要做的就是指定一个`std::variant`的东西,然后列出它的可能的数据类型
```cpp
#include<iostream>
#include<variant>

int main()
{
	std::variant<std::string, int> data;
	data = "Cherno";
	data = 2;
	data = false;
}
```
- 可以看到编译器依然可以给data赋值为列表之外的数据类型,但实际上我们之后就访问不了它了
</br>

- variant不像联合体一样共享内存,而是每个类型都会自己的内存,比如上面的data就有32字节(int有4字节,string有28字节)
</br>

- union更有效率,variant更加类型安全,不会造成未定义行为
***
# Lecture 78 存储任意类型的数据

- `std::async`用于实现异步运行函数,基本定义为std::async(启动类型,实际异步运行的函数, );
***
# Lecture 79 std::async
1. 为什么不能传引用？
线程函数的参数按值移动或复制。如果引用参数需要传递给线程函数，它必须被包装（例如使用std :: ref或std :: cref）
</br>

1. std::async为什么一定要返回值？
如果没有返回值，那么在一次for循环之后，临时对象会被析构，而析构函数中需要等待线程结束，所以就和顺序执行一样，一个个的等下去
如果将返回值赋值给外部变量，那么生存期就在for循环之外，那么对象不会被析构，也就不需要等待线程结束。


***
# Lecture 81 单例模式
- 单例只是一种组织一堆全局变量和静态函数的方式	
***
# Lecture 83 C++的小字符串优化
- 在标准库中,不是很长的字符串,它们不需要堆分配,而是分配给一小块基于栈的缓冲区,在VS2019的环境下,15字符及以下被认为是小字符
```cpp
#include<iostream>
#include<string>

void* operator new(size_t size)
{
	std::cout << "Allocating " << size << "byte\n";
	return malloc(size);
}

int main()
{
	std::string name = "Cherno";

	std::cin.get();
}
```
- 以上代码在VS2022里用release模式运行,你会发现根本没有开辟新的堆内存,当你把name改成16个字符及以上时输出就会看到开辟堆内存的结果了
***
# Lecture 85 左值和右值
- 左值在内存中有位置
- 右值没有存储空间,没有位置
- 不止字面量是右值,函数的结构也可以是右值
```cpp
int GetValue()
{
	return 10;
}

int main()
{
	int i = GetValue();
}
```
- 这个例子中,GetValue()返回一个临时值(右值),为什么是临时的? 因为即使它返回的是一个int,但是没有存储空间,它只返回值
</br>

- 因为GetValue()是右值,所以像`GetValue() = 5`这样给这个值赋值是行不通的,同时你也能看到编译器报错`表达式必须是可修改的左值`,可修改意味着它必须是非const的

```cpp
int& GetValue()
{
	static int value = 10;
	return value;
}

int main()
{
	int i = GetValue();
	GetValue() = 5;
}
```

- 把GetValue()函数改为左值引用就可以`GetValue() = 5`这样赋值了
</br>

- 如果定义一个`void SerValue(int value)`这样的函数,我们的参数既可以是左值也可以是右值; 左值参数: `SetValue(i)`; 右值参数: `SetValue(10)`;
- 当传右值参的函数被调用时,这个右值会被用来创建一个左值
</br>

- 在上面的代码中可以很快速的判断出哪些参数是临时的,因为不能将右值赋给左值引用,根据这个规则,改为`SerValue(int& value)`就能立马判断,参数为右值的调用`SetValue(10)`会立马报错
</br>

- 针对报错里的"非常量"这三个字,还有一个特殊的规则,虽然不能用左值来引用右值,也就是`int& a = 10;`,但是这么写`const int& a = 10;`,你会发现是可行的,这背后实际的情况是,编译器创建了一个临时的左值,然后将值赋给了a,如下:
```cpp
int temp = 10;
const int& a = temp;
```
- 这么做也同时支持了左值和右值,就比如: 将上面的定义改为`void SerValue(const int& value)`会发现`SetValue(i)`和`SetValue(10)`都可行了
</br>

- 那怎么写一个函数,只接受临时对象呢? 那就需要借助右值引用了,还是刚才的代码`void SerValue(const int&& value)`,你会发现`SetValue(i)`报错了
</br>

- 有什么用? 如果我们知道传入的是一个临时对象的话,那么我们就不需要担心它们是否活着,是否完整,是否拷贝,我们可以简单偷取它的资源,给到特定的对象,或者其他地方
***
# Lecture 88 参数求值顺序
```cpp
#include<iostream>

void PrintSum(int a, int b)
{
	std::cout << a << " + " << b << " = " << (a + b) << "\n";
}

int main()
{
	int value = 0;

	PrintSum(value++,value++);

	std::cin.get(); 
}
```
- 以上代码输出为
```
1 + 0 = 1
```
- 从输出可以看出是先调用了b,再调用了a, 吗?......
- 以上输出是在Debug模式下执行的,当你改为Release模式后会发现,输出变成了
```
0 + 0 = 0
```
</br>

- 真实答案是: 这是一种"未定义行为",C++标准并没有真正定义在这种情况应该发生什么,也就是说它会根据编译器的不同而变化
- 发生这种情况的原因是,编译器实际上被允许并行的计算出这些是什么
***
# Lecture 89 移动语义 
- 在我们写代码时,我们不需要或者不想把一个对象从一个地方复制到另一个地方,但是又不得不复制,因为这是唯一可以复制的地方
```cpp
#include<iostream>
#include<memory>

class String
{
public:
	String() = default;
	
	String(const char* string)
	{
		printf("Created!\n");
		m_Size = strlen(string);
		m_Data = new char[m_Size];
		memcpy(m_Data,string,m_Size);
	}

	String(const String& other)
	{
		printf("Copied!\n");
		m_Size = other.m_Size;
		m_Data = new char[m_Size];
		memcpy(m_Data,other.m_Data,m_Size);
	}

	~String()
	{
		delete m_Data;
	}

	void Print()
	{
		for (uint32_t i = 0; i < m_Size; ++i)
			printf("%c", m_Data[i]);

		printf("\n");
	}
private:
	char* m_Data;
	uint32_t m_Size;
};

class Entity
{
public: 
	Entity(const String& name)
		:m_Name(name)
	{
	}

	void PrinName()
	{
		m_Name.Print();
	}
private:
	String m_Name;
};

int main()
{
	Entity entity("Cherno");
	entity.PrinName();

	std::cin.get();
}
```
- 在Entity的构造函数初始化列表中，m_Name(name)会调用String的拷贝构造函数String(const String& other)
***
# Lecture 90 std::move与移动赋值操作符
- 赋值操作符,只有当我们把一个变量赋值给一个已有的变量时才会被调用
</br>

- C++三法则: 如果需要`析构函数`,则一定需要`拷贝构造函数`和`拷贝赋值函数`
- C++五法则: 为了支持移动语义,又在三法则的基础上又增加了`移动构造函数`和`移动赋值运算符`
</br>

- std::move是你想要将一个对象转换为临时对象时要做的
***

    