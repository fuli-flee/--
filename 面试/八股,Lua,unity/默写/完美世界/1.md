# 1.渲染管线
应用阶段 => 几何阶段 => 光栅化阶段 => 像素阶段

首先是准备各个顶点数据输入顶点着色,然后转换为图元,然后经过曲面细分,使其变得更加光滑;
然后是几何着色器,将图元输入后,将其扩展为更复杂的形式;
之后是图元装载的阶段,会进行三角形背面剔除,然后经过裁剪空间裁剪,然后将图片映射到屏幕空间中
接下来是光栅化,三角形会变成片段.再遍历获取顶点并进行插值,每个像素都会生成一个片元;
然后就是片元着色器,在这里可以进行光照计算、读取贴图颜色、设置透明度等操作
最后逐片元操作,裁切测试，透明测试，模板测试，深度测试

# 2.Lua与C++交互
Lua和C++ 的交互机制的基础在于Lua提供了一个虚拟栈，C++ 和Lua之间的所有类型的数据交换都通过这个栈完成。无论何时C++想从Lua中调用一个值，被请求的值将会被压入栈，无论何时C++想要传递一个值给Lua，首先将整个值压栈，然后就可以在Lua中调用。 

● Lua 和 C++ 的交互主要依赖于 Lua 的 C API。
● 数据传递通过栈完成，栈操作是交互的核心。
● C++ 可以调用 Lua 脚本中的函数，也可以将 C++ 函数注册到 Lua 中供其调用。

# 3.设计模式?MVC?
单例模式: 饿汉式和懒汉式(饿汉急着创建，懒汉拖延创建)
- 饿汉式：在类加载时就创建单例实例（起始时创建）
- 懒汉式：在第一次使用时才创建实例（需要的时候创建）

观察者模式: 
- 被观察者维护一个观察者列表
- 当被观察者状态发生变化时，自动通知所有注册的观察者
- 观察者接收到通知后执行各自的更新逻辑

MVC:
- 模型: 负责数据和业务逻辑,不直接与视图层交互
- 视图: 负责UI展示,不处理业务逻辑
- 控制器: 复杂接收用户输入
- 举例: 用户操作视图,然后视图将事件传输给控制器,控制器处理逻辑(可能更新模型),模型更新后,通知视图更新(观察者模式),视图从模型中获取数据并重新渲染

# 4.智能指针
shard_ptr,weak_ptr,unique_ptr

- 共享型指针: 内部维护一个引用计数,多个共享指针指向一个对象,只有当最后一个引用资源释放时销毁
- 弱指针: 提供对一个或多个shared_ptr实例所属对象的访问，但不参与引用计数, 用于解决共享型指针的循环引用问题
- 独占式指针: 只允许基础指针的一个所有者。可以移到新所有者（具有移动语义），但不会复制或共享（不能得到指向同一个对象的两个unique_ptr），