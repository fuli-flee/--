[toc]

# 基础部分
****
## 1.值类型和引用类型
**值类型** : 包含了所有简单类(int,bool,char,struct,enum)
**引用类型**:包含了string,object,class,delegate,interface,array

  1. 值类型存储在栈里,引用类型存储在堆里
  2. 值类型存取速度快,引用类型反之
  3. 值类型表示实际数据,引用类型表示数据的指针和地址引用
  4. 值类型变量直接把变量的值存在堆栈中,引用类型变量把实际数据的地址存在堆栈中

| **特性**            | **值类型（Value Type）**                  | **引用类型（Reference Type）**           |
|---------------------|------------------------------------------|------------------------------------------|
| **存储位置**        | 存储在**栈**（Stack）上。                    | 存储在**堆**（Heap）上。                     |
| **内存分配**        | 内存分配和释放速度快。                   | 内存分配和释放速度较慢，需要垃圾回收。   |
| **默认值**          | 默认值为零或等效值（如 `0`、`false`）。  | 默认值为 `null`。                        |
| **赋值行为**        | 赋值时**复制整个值**。                       | 赋值时**复制引用**（指向同一对象）。         |
| **示例类型**        | `int`, `float`, `bool`, `struct`, `enum`  | `class`, `string`, `array`, `delegate`   |
| **生命周期**        | 生命周期由作用域决定，**超出作用域自动释放**。| 生命周期**由垃圾回收器（GC）管理**。         |
| **性能**            | 访问速度快，适合小型数据。               | 访问速度较慢，适合大型或复杂数据。       |

面试官主要想听到: **存储位置**和**生命周期**
    
****
## 2.重载和重写的区别
封装,继承,多态的位置不同,重载是在同类中的,而重写是在父子类中的

  1. 定义方式不同: 重载是方法名相同参数列表不同,重写是方法名和参数列表都相同
  2. 调用方式不同: 重载使用相同对象的不同参数调用,重写是不同对象以相同参数调用
  3. 多态时机不同: 重载是编译时多态,重写是运行时多态
****

## 3.ArrayList和 List的主要区别
| **ArrayList**         | **List\<T>**                      |
|----------------------|----------------------------------|
|**非泛型**，可以存储任何类型的对象|**泛型**，只能存储指定类型 T 的元素|
|**需要拆装箱**|直接存储值类型，**无需拆装箱**。|

拓展: 
- 装箱: 将值类型转换为引用类型
- 拆箱: 将引用类型转换回值类型。

****
## 4.List底层是什么实现的?
List的底层实现是数组,它可以通过索引来访问元素
当对List增加元素时,List会自动重新分配容器空间,所以最好一开始就初始化好数量

具体扩容: 当增加元素但列表容量不足以再添加新元素时,会先开辟一个数组大小是原来的两倍的空间,然后将现有的元素都复制过去,所以时间复杂度是O(n)

****
## 5.LinkedList和List有什么区别?
List是基于数组的数据结构,它可以通过索引去查找元素,所以它可以进行随机访问,List需要重新分配内存以扩容,因此增加或删除元素性能较低,适用于需要随机访问的场景

LikedList是基于链表的数据结构,它不支持随机访问,要访问元素需要从头结点开始遍历,但是在增加或删除元素时,LinedList只需要改变节点指针,适用于需要频繁增删元素的场景

关键词: 底层,增删元素,性能,适用场景

****
## 6.Interface和abstract(接口与抽象类)
1. 接口完全抽象,抽象类部分抽象.说人话就是接口只声明方法,没有实现,抽象类要有没有实现的抽象方法,但它里面也可以实现其他的具体方法,让子类能使用
2. 接口可以多继承,而抽象类只能单继承
3. 接口不能被实例化,虽然抽象类也不能,但是它可以通过子类间接实例化

****
## 7.构造函数是否能被重写？
不能被重写,但是能被重载

提一下:重写（override）仅适用于被标记为 **virtual**、**abstract** 或 override 的实例方法或属性

****
## 8.静态成员与非静态成员
  1. 静态成员由static修饰,类被第一次加载到内存时创建,**通过类访问**,所以它全局唯一,所有调用共享一个成员
  2. 非静态成员,在对象实例化的时候创建,**通过对象调用**
  3. 静态方法里不能有非静态成员,而非静态方法里可以有静态成员
  4. 静态成员属于类,非静态成员属于对象

****
## 9.ref和out
ref修饰引用参数,所以在引用前参数需要初始化赋值,带回返回值,又进又出,意思就是说,在方法里修改了变量,那也就相当于修改了变量本身
out修饰输出参数,参数可以不赋值,但是在返回值之前必须赋值

它们都不创建新的存储位置

ref参数是值类型,原先的数据会随着方法里的数据改变而改变
ref参数是引用类型,在方法里重新赋值后,会覆盖原来的初始值,使用方法里的新值
****
## 10.string str = null , string str = "" , string str = string.Empty()的区别

null: 初始化对象,不分配内存
"": 初始化对象,分配了一个的空字符串对象的内存空间
empty: 完全等价于上面这个(string str = "")

****
## 11.const和readonly
都用于标识一个常量

1. 初始化位置不同,const必须在声明的时候赋值;readonly可以在声明的时候赋值,也可以在构造方法里赋值
2. const默认是静态的,readonly要静态必须显式
3. const是编译时常量,readonly是运行时
4. 对于引用类型参数,const只能修饰string和值为null的其他引用类型,而readonly可以修饰任何类型
****
## 12.对于string多次使用+=会产生大量内存垃圾,怎么解决
先说结论,用string builder的append

**为什么会有垃圾?**
  string定义了就不变了,所以当+=时候,实际上又创建了一个全新的字符串对象,让原变量指向它,原对象不再引用就会被标记垃圾

**为什么StringBuilder不会有垃圾**
  string builder内部维护一个动态字符数组,一般会分配一个缓冲区,拼接字符时缓冲区够就直接追加,不够就翻倍扩容

**String 与 StringBuilder**
  讲讲上面没有的
  String是字符串常量,线程安全;
  StringBuilder是字符串变量,线程不安全;
  
  解释一下线程安不安全: 因为string内部存在一个只读的字符数组里,因此不会改变原字符串的内容,多线程并发访问string时，无论做什么操作（读取、修改），都不会出现 “一个线程修改，另一个线程读取到中间状态” 的问题;StringBuilder就相反咯(可修改的字符数组,直接操作内部数组)
****
## 13.String s = new String(“xyz”);创建了⼏个String Object?
两个, 先在常量池创建字符串对象"xyz",然后new string()会在堆里创建一个新的引用对象指向"xyz"
****
## 14.C#是否可以继承string类
  1. String类被显式定义成了sealed类,sealed关键字的作用就是禁止其他类继承该类
  2. 在.NET运行时中，字符串有着特殊的优化处理，例如字符串驻留（String Intern Pool）。这种机制要求字符串必须保持不可变性。要是允许继承，这些底层优化策略就很难实现。
****
## 15.string 与 stringBuilder的区别
  1. string是常量,线程安全;stringBuilder是变量,线程不安全
  2. string对象是不可变的,当string对象改变时会生成一个新的string对象,然后将指针指向这个新的对象,不适合频繁改变字符的场景
  3. stringBuilder对象是可变的,当对其字符连接的时候只是在原来的字符串上进行修改,适用于连接频繁的场景
****
## 16.struct与class(结构体与类的区别)
  1. 结构体是值类型,类是引用类型
  2. 结构体就是当值使用的,类则是通过引用来对实际数据操作的
****
## 17.(x.equals(y) == true)
说明这两个对象的值相同,hashcode也相同
  
   - 如果两个对象相同,那么它们的hashcode也一定相同
   - 如果两个对象hashcode相同,它们不一定相同,因为有哈希冲突的可能
### hash code
- 定义：hashcode是对象的一种哈希值，在 C# 中，可通过调用对象的GetHashCode()方法来获取。
- 用途：在哈希表（如Dictionary<TKey, TValue>）中，hashcode能确定对象应该被存储的 “桶” 位置，这样可以加快数据查找速度。
****
## 18.2乘8最快的运算方法
位运算, 2<<3
****
## 19.int?和int有什么区别
- int?可以为空类型,默认值可以为null
- int默认值为0
- int?是int通过装箱为引用类型来实现的
****
## 20.i++和++i的区别
- i++: 先赋值,后自增
- ++i: 先自增,后赋值
- Tips: i++的效率比++i的效率要低，因为i++在返回的时候需要先拷贝一次自增前的值作为返回值。然后再对本身+1。所以很多时候看到LeetCode中的解法大多使用的是++i而不是i++。
****
## 21.C# sealed修饰符
sealed修饰符用于密封

**用法**:
- 用于类的时候,该类不能被继承,因此与abstract相斥
- 用于方法和属性的时候,表示该方法和属性不能再被重写,必须与override关键字一起使用,因为使用sealed一定是基类的虚成员(想想为什么,因为基类虚方法不能用sealed,因为含义上相斥啊)

**用处**:
- 通常在实现第三方类库时不想被客户端继承，或用于没有必要再继承的类以防止滥用继承造成层次结构体系混乱。
- 恰当的利用sealed修饰符也可以提高一定的运行效率，因为不用考虑继承类会重写该成员
****
## 22.for与foreach
- foreach是只读循环,无法对循环的数组或集合进行修改
- 在给定长度且不需要计算长度的情况下,for的效率高于foreach
- 在不确定长度或计算长度有损性能的情况下,foreach更加方便
- foreach循环的时候会释放使用完的资源,造成额外的gc开销
****
# 中级部分
****
## 1.C#可否对内存直接操作
- 在unsafe模式下可以使用指针对内存操作
- 在托管模式下不可以使用指针
- .NET默认不运行带指针的,需要设置下，选择项⽬右键->属性->选择⽣成->“允许不安全代码”打勾->保存
****
## 2.什么是匿名方法?
是一种没有显式名称的方法，主要用于创建简短的代码块,用作委托的参数的一段代码
****
## 3.什么是闭包?
- 通过lamda表达式可以访问到表达式之外的变量,这就成为闭包
- 当引⽤外部变量时，需要注意，外部变量变化时，lambda表达式的结果也可能会随着外部变量变化⽽变 
化
****
## 4.CTS,CLS,CLR是什么?
  - CTS : (*Common Type System*)通用类型系统
  - CLS : (*Common Language Specification*)通用语言规范
  - CLR : (Common Language Runtime)公共语言运行库
  
****

## 5.装箱和拆箱
### 装箱
- **定义**
  - 装箱是将 `值类型` 转换为 `引用类型` 的过程。具体来说，值类型的数据会被复制到堆上，并创建一个对象来包装它。
- **过程**
    - 在**堆**上分配内存，用于存储值类型的数据。
    - 将值类型的数据**复制到堆上**的内存中。
    - 返回**堆上对象的引用**。
### 拆箱
- **定义**
  - 拆箱是将 `引用类型` 转换回 `值类型` 的过程。具体来说，堆上的对象会被解包，并将数据复制回栈上的值类型变量。
- **过程**
  - **检查**引用类型对象是否为对应的值类型。
  - 将堆上的**数据复制到栈上**的值类型变量中。

面试官主要想听到: 定义,内存位置上的转移,最重要的是GC方面的
***
## 6.如何优化拆装箱的效率
1. Struct通过重写函数来避免拆装箱
    - 比如常用的ToString(),GetType()方法,如果没有重写ToString()和GetType()方法,就会在struct实例调用它们时先装箱再调用,导致内存重新分配性能损耗,所以对于那些需要调用的方法,必须重写
2. 通过泛型来避免拆装箱
    - 比如B,C继承与A,就可以有这个泛型方法void Test(T t)where T:A,以避免使用object引用类型形式传递参数
3. 通过继承统一的接口提前拆装箱,避免多次拆装箱
    - 很多时候拆装箱不可避免，那么我们就让多种 Struct 继承某个统一的接口，不同的 Struct 就可以有相同的接口。把 Struct 传递到其他方法里去时就相当于提前进行了装箱操作，在方法中得到的是引用类型的值，并且有它需要的接口，避免了在方法中重复多次的拆装箱操作。
***
## 7.C#常用容器类
- **stack(栈)**: 先入后出,底层是泛型数组实现,入栈动态扩容2倍
- **Queue(队列)**: 先进先出,底层是泛型数组实现,表头表尾指针,用size去判断空或满
`栈和队列主要是用来存放临时信息的`
- **Array(数组)**: 需要声明长度,不安全
- **ArrayList(数组列表)**: 动态增加数组,不安全,实现了IList接口,用Object数组实现
- **List(列表)**: 底层是泛型数组,动态扩容,泛型安全
`泛型数据对于值类型来说就是数据本身,对于引用类型来说就是引用,当泛型数据存储到泛型数组里时,添加元素超出当前容量,则会2倍扩容,进而实现List的大小动态改变`
- **LinkList链表**
  1. 数组和List、ArrayList集合都有一个重大的缺陷，就是从数组的中间位置删除或插入一个元素需要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。
  2. LinkedList（底层是由链表实现的）基于链表的数据结构，很好的解决了数组删除插入效率低的问题，且不用动态的扩充数组的长度。
  3. LinkedList的优点：插入、删除元素效率比较高；缺点：访问效率比较低。
- **HashTable哈希表（散列表）**
  1. 概念：不定长的二进制数据通过哈希函数映射到一个较短的二进制数据集，即Key通过HashFunction函数获得HashCode
  2. 装填因子：α=n/m=0.72 ,存储的数据N和空间大小M
  3. 然后通过哈希桶算法，HashCode分段，每一段都是一个桶结构，一般是HashCode直接取余。
  4. 桶结构会加剧冲突，解决冲突使用拉链法，将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。
       - Key—Value形式存取，无序，类型Object，需要类型转换。
       - Hashtable查询速度快，而添加速度相对慢
       - Hashtable中的数据实际存储在内部的一个数据桶里（bucket结构体数组），容量固定，根据数组索引获取值。

***
## 8.构造函数是否能重写
构造器不能被继承,因此也不能被重写,但是可以重载
1. 构造器不是成员方法，而是对象初始化逻辑
2. 如果构造器可以继承，会导致初始化逻辑混乱
###  C# 如何让子类“复用”父类构造器？
虽然构造器不能继承，但 C# 提供了 **base()** 和 **this()** 机制，让子类可以显式调用父类构造器或复用当前类的其他构造器。
***
## 9.C#中using的三种用法
1. 引用命名空间,在使用类时可以省略复杂的前缀,C#10新特性支持全局using，如果关键字 global 出现在 using 指令之前，则 using 适用于整个项目
2. 定义命名空间的别名
3. 自动释放所创建的对象
     - 在定义域内的代码运行结束后,自动调用IDisposable,释放新建的非托管型的系统资源,简化了try catch的写法 
***
## 10.C#几种循环的方法?
- for: 使用于确定次数的循环
- foreach: 使用于遍历的元素,只读
- do...while: 次数不确定,条件随机变化,但是至少保证可以执行一次
- while: 次数不确定,条件随机变化
***
## 11.接⼝是否可继承接⼝？抽象类是否可实现（implements）接⼝？抽象类是否可继承实现类（concrete class）？
- 接口可以继承接口, 且一个接口可以继承多个接口
```css
// 父接口
public interface IAnimal
{
    void Eat();
}

// 子接口继承父接口
public interface IDog : IAnimal
{
    void Bark();
}

// 实现类需要实现所有接口方法
public class Labrador : IDog
{
    public void Eat()
    {
        Console.WriteLine("Labrador is eating");
    }
    
    public void Bark()
    {
        Console.WriteLine("Labrador is barking");
    }
}
```
- 抽象类可以实现接口,且可以选择实现部分接口方法（未实现的方法需声明为抽象方法）
```css
public interface IFlyable
{
    void Fly();
    void Land();
}

// 抽象类实现接口
public abstract class Bird : IFlyable
{
    // 实现部分接口方法
    public void Land()
    {
        Console.WriteLine("Bird is landing");
    }
    
    // 未实现的接口方法需声明为抽象方法
    public abstract void Fly();
}

// 继承抽象类的子类需实现剩余抽象方法
public class Eagle : Bird
{
    public override void Fly()
    {
        Console.WriteLine("Eagle is flying high");
    }
}
```
- 抽象类可以继承实现类，如果父类有非虚方法，子类无法重写；如果需要重写，父类方法需声明为virtual
```css
// 具体类（实现类）
public class Vehicle
{
    public void Move()
    {
        Console.WriteLine("Vehicle is moving");
    }
    
    // 允许子类重写的方法
    public virtual void Fuel()
    {
        Console.WriteLine("Vehicle uses fuel");
    }
}

// 抽象类继承具体类
public abstract class Car : Vehicle
{
    // 可以新增抽象方法
    public abstract void Honk();
    
    // 可以重写父类的虚方法
    public override void Fuel()
    {
        Console.WriteLine("Car uses gasoline");
    }
}

// 具体子类实现抽象方法
public class Sedan : Car
{
    public override void Honk()
    {
        Console.WriteLine("Sedan is honking: Beep beep");
    }
}
```
***
## 12.用双检锁实现一个单例模式
```css
public class Singleton
{
    private static Singleton _instance;
    private static readonly object _lock = new object();
 
    private Singleton() 
    {
    }
 
    public static Singleton Instance
    {
        get
        {
            if (_instance == null)
            {
                lock (_lock)
                {
                    if (_instance == null)
                    {
                        _instance = new Singleton();
                    }
                }
            }
            return _instance;
        }
    }
}
```
### 懒汉模式
懒汉模式就是加载类的时候只声明变量，不new对象，后面用到的时候再new对象，然后把对象赋给该变量
```css
public class Singleton {
    
  	private static Singleton INSTANCE;
  
  	// 构造器私有化
  	private Singleton() {}
  	
  	public static Singleton getInstance() {
      	if (INSTANCE == null) {
          	INSTANCE = new Singleton();
        }
      	return INSTANCE;
    }
}
```

### 饿汉模式
饿汉模式就是加载类的时候直接new一个对象，后面直接用即可
```css
public class Singleton {
    // 使用static修饰，类加载的时候new一个对象
  	private static Singleton INSTANCE = new Singleton();
  
  	// 构造器私有化
  	private Singleton() {}
  	
  	public static Singleton getInstance() {
      	return INSTANCE;
    }
}
```

### 如何运作?
- First Null Check：在获取锁之前，代码会检查实例是否已创建。如果不是，则输入锁定块。
- Locking：如果尚未创建实例，则代码会锁定critical部分(临界区)，以确保没有其他线程可以同时创建实例。
- 第二次空检查：获取锁后，它会再次检查实例是否仍为null。这是必要的，以避免多个线程可能通过第一次检查并尝试同时创建实例的竞争条件。

###  为什么要使用双重检查锁定？
双重检查锁定可以确保单例是**延迟初始化**以及**线程安全**的,并注重**性能优化**
  1. **延迟初始化**: 仅在首次需要的时候创建单例,而不是在应用开始时创建,从而可以节省资源并且可以避免不必要的数据库链接或对象创建
  2. **减少锁定开销**: 如果没有双重检查锁定，则每次访问Instance属性时都会执行该lock语句，即使在已创建Singleton实例之后也是如此。这种常量锁定会带来不必要的开销，尤其是在经常访问单例的高性能或多线程环境中。
     - 使用双重检查锁定时，该方法首先检查实例是否已创建，而无需获取锁定（第一次null检查）。如果实例存在，它将完全跳过锁，从而显著提高Singleton已初始化的常见情况下的性能。
  3. **线程安全**: 在第一次访问期间，如果Singleton尚未创建，则锁确保只有一个线程初始化实例。初始化后，后续线程将绕过锁，从而避免在将来的访问中降低性能。
  4. **避免争用**: 通过使用两项检查，您可以确保一旦线程位于lock块内，它会在创建实例之前重新检查实例的状态，从而防止多个线程同时创建不同的实例。
***
## 13.设计模式有哪些
[看这个](https://design-patterns.readthedocs.io/zh-cn/latest/index.html)
23种设计模式,三个大类
1. **创建型模式**`关注于对象的创建，同时隐藏创建逻辑`: ⼯⼚模式、抽象⼯⼚模式、单例模式、建造者模式、原型模式
2. **结构型模式**`关注类和对象之间的组合`: 适配器模式、过滤器模式、装饰模式、享元模式、代理模式、外观模式、组合模式、桥接模式
3. **行为型模式**`关注对象之间的通信`:  责任链模式、命令模式、中介者模式、观察者模式、状态模式、策略模式、模板模式、空对象模式、备忘录模式、迭代器模式、解释器模式、访问者模式
***
## 14.简单工厂模式
简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

**优点**: 
- ⼯⼚类含有必要的判断逻辑，可以决定在什么时候创建哪⼀个产品类的实例，客户端可以免除直接创建产品对象的责任，⽽仅仅“消费”产品；简单⼯⼚模式通过这种做法实现了对责任的分割，它提供了专⻔的⼯⼚类⽤于创建对象； 
- 客户端⽆须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于⼀些复杂的类名，通过简单⼯⼚模式可以减少使⽤者的记忆量； 
- 通过引⼊配置⽂件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在⼀定程度上提⾼了系统的灵活性。 
  
**缺点**:
- 不易拓展，⼀旦添加新的产品类型，就不得不修改⼯⼚的创建逻辑； 
- 产品类型较多时，⼯⼚的创建逻辑可能过于复杂，⼀旦出错可能造成所有产品的创建失败，不利于系统的维护。
***

## 15.什么是强类型,弱类型?
- 强类型就是在编译是就确定类型的数据,执行时类型不能更改
- 弱类型在执行时才会确定类型
- 强类型因为事先已经确定好了,效率高,所以一般用于编译型语言,如C++,C#,java
- 弱类型相较不安全,在运行时容易出错,但是它灵活,一般用于解释型语言,如php,javascript
***
## 16.Set⾥的元素是不能重复的，那么⽤什么⽅法来区分重复与否呢? 是⽤==还是equals()? 它们有何区别?
- Set⾥的元素是不能重复的，那么⽤iterator()⽅法来区分重复与否。
- equals()是判断两个Set是否相等。 
- equals()和==⽅法决定引⽤值是否指向同⼀对像，equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。
***
## 17.什么是匿名类，有什么好处？
不⽤定义、没有名字的类，使⽤⼀次便可丢弃。好处是简单、随意、临时的。
***
## 18.a.Equals(b)和a==b⼀样吗？
不⼀样，a==b仅仅表示a和b值相等，a.Equals(b)表示a与b⼀致

1. "==" : 操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。
2. "equals" : 操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。 
3. 对于值类型，==和equals等价，都是比较存储信息的内容。
4. 对于引用类型，==比较的是引用类型在栈中的地址，equals方法则比较的是引用类型在托管堆中的存储信息的内容。
***
## 19.什么是虚方法?与抽象方法有什么不同?
- 一个虚方法必须有一个默认实现，我们可以在派生类中使用override关键字来覆盖这个虚方法。抽象方法没有实现，只在抽象类内部创建。
- 在抽象类的情况下，从抽象类派生的类必须具有该抽象方法的实现。
***
## 20.是否可以从一个static方法内部发出对非static方法的调用？
不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部不能发出对非static方法的调用。
***
# 高级部分
***
## 1.浮点数的精度问题

#### 1.1 数值比较不相等
- 我们在写程序时经常会遇到到阀值触发某逻辑的情景，比如某个变量，需要从0开始加，每次加某个小于0.01的数，加到刚好0.23时做某事，到0.34时做另外一件事，到0.56时再做另一件。
- 这种精确定位的问题，就会遇到麻烦。因为浮点数在加减乘数时无法完全准确定位到某个值，就会在出现，要么比0.23小，要么比0.23大，永远不会刚刚与0.23相等的时候，这时我们不得不放弃 ‘==’ 这个等于号而选择‘>’大于号或者‘<’小于号来解决这种问题的出现。
- 如果一定要用等于来做比较，则需要有一个微小的浮动区间，即 abs(X-Y) < 0.00001 时认为 X 和 Y 是相等的。

#### 1.2 数值计算不确定
- 比如 x = 1f，y = 2f，z = 1f /5555f * 11110f，如果 x / y <= 0.5f 时做某事，那么理论上说 x / z 也能通过这个if，因为在我们看来z 就等于 2 和 y是一样，但实际上未必是这样的。浮点数在计算时由于位数的限制无法得到精确的数值而是一个被截断的数值，因此 z 的计算结果有可能是0.4999999999991，当x / z 时，结果有可能得到大于0.5。
- 这让我们很头疼，在实际编码中，我们经常会遇到这样的情况，在外圈的if判断成立，理论上同样的结果只是公式不同，它们在内圈的if判断却可能不成立，使得程序就出现异常行为，因为看起来应该是得到同样的数值，但结果却不一样。

#### 1.3 不同设备计算结构不同
不同平台上的浮点数计算也有所偏差，由于不同设备上CPU的计算方式不同，导致相同的公式在不同的设备上计算出来的结果有略微的偏差。

### 解决方法
1. **可以简单点，只计算一次，认定这个值为准确值，只用这个变量结果做判断，也省去了多次计算浪费的CPU**。当然这种方法使用范围比较小，可能不适用你所在的项目我们可以继续看看其他的解决方案。
2. **可以改用int或long型来替代浮点数**。浮点数和整数的计算方式都是一样的，只是小数点部分不同而已，那么完全可以把浮点数乘以10的幂次得到更准确的精度部分的数字，把自己需要的精度提上来用整数表示。
3. **用定点数保持一致性并缩小精度问题**，浮点数在计算机中的表示方法是用 V = (-1)^s x (1.M) x 2^(e) 这样的公式表示的，也就是说浮点数的表达其实是模糊的，它用了另一个数乘以2的幂次来表示当前的数。定点数则不同，它把整数部分和小数部分拆分开来，都用整数的形式表示，这样一来计算和表达都使用整数的方式。由于整数的计算是确定的，这样就不会存在误差，缺点是由于拆分了整数和小数，两个部分都要占用空间，所以受到存储位数的限制，占用字节多了通常使用64位的long型整数结构来存储定点数，计算的范围也会相对缩小些。
4. **最耗的办法，用字符串替代浮点数**。如果想要精确度很高很高，那么就可以用字符串代替浮点数来计算结果。但它的缺点是CPU和内存的消耗特别大，如果只是少量使用高精度计算还是可以的。

Tips: 定点数是计算机中表示数字的一种方式，主要用于在有限的存储空间内表示数值，其特点是小数点的位置固定不变。与浮点数（小数点位置可浮动）不同，定点数的小数点位置是预先约定好的
***
## 2.IList 接⼝与List的区别是什么?
1. **本质**: IList<T>是一个接口,定义了列表的基本操作,但不提供具体实现;List<T>是一个具体类,实现了IList<T>接口,并提供了完整的实现
2. **实现方式**: IList<T>需要开发者自行实现方法;List<T>是.NET提供的现成实现,直接可用
3. **功能范围**: IList<T>仅提供接口定义的方法,无法直接访问List<T>特有的优化功能;List<T>不仅实现了IList<T>,还扩展了更多实用方法
4. **使用场景不同**: IList<T>可灵活实现接口，按需控制修改权限,所以适用于需要自定义列表行为的场景;List<T>直接使用现成的高效实现，无需重复造轮子,所以适用于常规动态列表，需要增删改查的场景
5. **性能差异**: List<T> 针对性能优化（如动态扩容、连续内存存储），适合高频操作;IList<T> 的性能取决于具体实现（如数组 T[ ] 也是 IList<T>，但大小固定）。

Tips: List<T> 是 C# 中最常用的**动态数组**
***
## 3.泛型的主要约束和次要约束是什么？
- 当一个泛型参数没有任何约束时,它进行的操作和运算是有限的,因为不能对实参进行任何类型上的保证,这时候就需要泛型约束. 
- 泛型的约束分为: 主要约束和次要约束,它们都使参数必须满足一定的规范,C#编译器在编译的过程可以根据约束来检查所有泛型类型的实参并确保其满足约束条件

(1) 主要约束
一个泛型参数至多拥有一个主要约束,主要约束可以是一个引⽤类型、class或者struct. 如果指定一个引用类型(class),那么实参必须是该类型或者该类型的派生类型;相反,struct则规定了实参必须是一个值类型
(2) 次要约束
次要约束主要是指实参实现的接⼝的限定。对于⼀个泛型，可以有0到⽆限的次要约束，次要约束规定了实参必须实现所有的次要约束中规定的接⼝。次要约束与主要约束的语法基本⼀致，区别仅在于提供的不是⼀个引⽤类型⽽是⼀个或多个接⼝。

Tips: 
这种就是无约束
```css
public class ClassT1<T>
```
这种就是主要约束
```css
public class ClassT1<T> where T : Exception
```
这种就是有次要约束
```css
public class ClassT3<T> where T : struct, IComparable 
```
***
## 4..NET默认的委托类型有哪些?
1. Action
  泛型Action 委托表示引用一个void返回类型的方法,存在16中重载方法 
2. Func 
  Func调用带返回类型的方法,有16重载方法
***
## 5.结构体能实现接口吗?
可以
***
## 7.如何理解C#委托?
1. 什么是委托?
委托可以理解为持有一个或多个方法的对象. 如果执行委托的话,委托会执行它所"持有" 的方法. 委托可以避免程序大量使用if-else语句,使程序拥有更好的拓展性
2. 委托的本质?
委托和类一样,是一种用户自定义的类型,但类表示的是数据和方法的集合,而委托则持有一个或多个方法,以及一系列预定义的操作
3. 如何声明委托?
```delegate void MyDel(int x)```
说明：delegate 作为委托关键字，没有方法主体
4. 什么是多播委托?
可以把多个方法赋值给同一个委托，或者将多个方法绑定到同一个委托，就是多播委托。
***
## 8.什么是事件(event)? 它和委托(delegate)的关系?
- 事件在委托上又做了一次封装,意义是限制用户直接操作委托实例中变量的权限
- 封装后,用户不再能够直接赋值(用=)操作来改变委托变量,只能通过注册或者注销委托的方法来增减委托函数的变量,虽然事件声明的委托不再提供"="操作符,但仍然有"+="和"-="的操作符来操作
- 为什么要限制呢？
  - 因为在平时的编程中，由于项目太过庞大，经手的人员数量太多，导致我们常常无法得知其他人在编写的代码是什么有什么意图，这样公开的delegate委托会直接暴露在外，随时会被‘=’赋值而清空了前面累积起来的委托链表，委托的操作权限范围太大导致问题会比较严重。申明 event 后，编译器内部重新封装了委托，让暴露在外面的委托不再担心随时被清空和重置的危险。因为经过 event 封装后不再提供赋值操作来清空前面的累加，只能一个个注册或者一个个注销委托(或者说函数地址)，这样就保证了谁注册就必须谁负责销毁的目的，更好的维护了delegate的秩序。
***
## 9.什么是泛型委托?
Action就是泛型委托。

注意事项： 
1. 建议尽量使⽤这些委托类型，⽽不是在代码中定义更多的委托类型。这样可以减少系统中的类型数 
⽬，同时简化编码 
2. 如果需要使⽤ref或out关键字，以传引⽤的⽅式传递⼀个参数，就可能不得不定义⾃⼰的委托： 
`delegate void Test(ref int i) `
3. 如果委托要通过C#的params关键字获取可变数量的额参数，要为委托的任何桉树指定默认值，或者要对委托的泛型类型参数进⾏约束，也必须定义⾃⼰的委托类型 
`delegate void EventHandler(Object sender, TEventArgs e) where TEventArgs : EventArgs; `

4. 使⽤获取泛型实参和返回值的委托时，可利⽤逆变与协变。逆变：⽗类转换为⼦类；协变：⼦类转换为⽗类

*** 
## 10.try {}⾥有⼀个return语句，那么紧跟在这个try后的finally {}⾥的code会不会被执⾏，什么时 候被执⾏，在return前还是后?
会执⾏，在return前执⾏。

***
## 11.C#中 property 与 attribute的区别，他们各有什么用处，这种机制的好处在哪里？
property和attribute汉语都称之为属性。不过property是指类向外提供的数据区域。而attribute则是描述对象在编译时或运行时属性的。这两者是有本质区别的

***
## 12.反射的实现原理？
反射 是 .NET 提供的机制，允许在运行时动态获取类型信息（如类、方法、属性等），并调用它们。
反射是审查元数据并收集关于它的类型信息的能力，元数据（编译后的最基本数据单元）一些表。可以在加载程序运行时，动态获取和加载程序集，并且可以获取到程序集的信息反射即在运行期动态获取类、对象、方法、对象数据等的一种重要手段

### 优缺点
**优点：**
1. 反射提高了程序的灵活性和扩展性。
2. 降低耦合性，提高自适应能力。
3. 它允许程序创建和控制任何类的对象，无需提前硬编码目标类。
  
**缺点：**
1. 性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。
2. 使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。

***
## 13.解释一下var和dynamic?
1. var是语法糖,编译的时候确定类型
   1. 必须在声明的时候初始化
   2. 类型一旦确定就无法更改(静态类型)
   3. 编译后会被替换为实际类型
2. dynamic是 .NET 提供的动态类型机制,绕过编译时类型检查,在运行时动态解析类型
   1. 不需要初始化即可声明
   2. 类型可以任意变换
   3. 编译是不检查变量是否存在

***
## 14.如何避免类型转换时的异常
- 其中有些是确定可以转换的（⽐如将⼀个⼦类类型转为⽗类类型），⽽有些则是尝试性的（⽐如将基类引⽤的对象转换成⼦类）。当执⾏常识性转换时，我们就应该做好捕捉异常的准备。
- 当⼀个不正确的类型转换发⽣时，会产⽣InvalidCastException异常，有时我们会⽤try-catch块做⼀些尝试性的类型转换，这样的代码没有任何错误，但是性能却相当糟糕，为什么呢？异常是⼀种耗费资源的机制，每当异常被抛出时，异常堆栈将会被建⽴，异常信息将被加载，⽽通常这些⼯作的成本相对较⾼，并且在尝试性类型转换时，这些信息都没有意义。
- 在.NET中提供了另外⼀种语法来进⾏尝试性的类型转换，那就是关键字 is 和 as 所做的⼯作。

(1) is只负责检查类型的兼容性,并返回true和false -> 进行类型判断
(2) as不仅负责检查兼容性还会类型转换,并返回结果,如果不兼容则返回null  -> 用于类型转换

- 两者的共同之处都在于：不会抛出异常！综上⽐较，as 较 is 在执⾏效率上会好⼀些，在实际开发中应该量才⽽⽤，在只进⾏类型判断的应⽤场景时，应该多使⽤ is ⽽不是 as。
***
## 15.Dictionary底层原理
字典数据结构,是以关键字Key和值Value进行一一映射的.Key的类型并没有做任何的限制，可以是整数，也可以是的字符串，甚至可以是实例对象。关键字Key是如何映射到内存的呢？
对于Dictionary的实现原理，其中有两个关键的算法，
- 一个是Hash算法，
- 一个是用于应对Hash碰撞冲突解决算法。

**实现原理**
 - 哈希算法：将不定长度的二进制数据集给映射到一个较短的二进制长度数据集一个Key通过HashFunc得到HashCode
 - Hash桶算法：对HashCode进行分段显示，常用方法是对HashCode直接取余，桶本身是用的数组。
 - 解决碰撞冲突算法（拉链法）：分段会导致key对应的桶会相同，拉链法的思想就像对冲突的元素，建立一个单链表，头指针存储到对应的哈希桶位置。反之就是通过确定hash桶位置后，遍历单链表，获取对应的value
 
Dictionary 是以数组为底层数据结构的类。当我们实例化 new Dictionary() 后，内部的数组是0个数组的状态。与 List 组件一样，Dictionary 也是需要扩容的，会随着元素数量的增加而不断扩容
***
## 16.C#的GC
- **工作原理**: **分代回收**
  - **第 0 代**: 最年轻的代，其中包含**短生存期对象(临时变量)**,垃圾回收最常发生在此代中。
  - **第 1 代**: 这一代包含短生存期对象并用作**短生存期对象和长生存期对象之间的缓冲区**。
  - **第 2 代**:  这一代包含**长生存期对象**(服务器应用程序中的一个包含在进程期间处于活动状态的静态数据的对象。)

### Unity中的GC
- **工作原理**: **标记-清除**
  - 用的是贝姆GC,是一种基于标记清除法的GC方式。
  - 1）GC会检查堆内存上的每个存储变量；
  - 2）对每个变量会检测其引用是否处于激活状态；
  - 3）如果变量的引用不再处于激活状态，则会被标记为可回收；
  - 4）被标记的变量会被移除，其所占有的内存会被回收到堆内存上。

***
## 17.委托和事件
[小白龙龙的回答很通俗,在这篇文章的第二个回答](https://www.zhihu.com/question/62183440/answer/23625975234)

### 委托
- 委托实际上就是C++里的函数指针,但是呢又有一些不一样的地方:
  - **面向对象**
    - 定义委托：例如 delegate void Demo(), 本质上就是定义一个叫做的 Demo 的类。
    - 创建委托实例。
    - 使用委托：ptr() 或 ptr.Invoke() 前者本质上就是后者的语法糖
  - **类型安全**
    - 委托**作为一个特殊的托管类**，同样遵循其它类的一般规则，**不允许转换为不兼容的类型**。即便是返回值类型和参数列表相同，但委托名称不同，在CLR看来都是两个相互独立的类, 不可以相互转型。
  - **多播**
    - 简单来说，多播就是允许开发者为同一个委托对象绑定多个方法。执行委托时，这些方法会被依次执行。

### 事件
- 事件就是**对委托的一次封装**。
  - 委托本质是一个类，委托对象就是这个类的实例。既然是对象，就和其它作为字段的对象一样，最好封装起来，不要轻易暴露给外界。实践中，我们会把字段封装成属性，然后提供给外部访问。对于委托类型的字段来说，则是封装成事件。

### 区别
- 委托是一种类型，它可以存储对方法的引用，并且**可以在任何地方调用**（触发）。委托没有访问权限的限制，只要你能访问到委托对象，就可以调用它。
- 事件是对委托的封装，它**限制了委托的触发权限**。事件**只能在定义它的类的内部触发**，**外部代码只能订阅或取消订阅事件，而不能直接触发事件。**

#### Action<>, Func<> 的区别
微软内置的泛型委托,两者的区别在于**前者没有返回值**而**后者有返回值且必须指定返回值类型**。

***
# 多线程
***

