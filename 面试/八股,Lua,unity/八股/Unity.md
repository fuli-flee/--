[toc]

****
# 1.四元数

四元数用于表示旋转
## 1.1相对于欧拉角的优点
- 避免万向锁
- 只需要一个4维的四元数就可以执行绕任意过原点的向量的旋转,方便快捷
- 可以提供平滑插值
****
# 2.什么是欧拉角?
⽤⼀句话说，欧拉⻆就是物体绕坐标系三个坐标轴(x,y,z轴)的旋转⻆度。 欧拉角eulerAngles在Unity3D是一个Vector3类的变量，官方约定俗成的层级关系是ZXY，即最里层是Z轴先旋转，中间层是X轴，最外层是Y轴。

## 1.1静态：
即绕世界坐标系三个轴的旋转，由于物体旋转过程中坐标轴保持静⽌，所以称为静态。 
## 1.2动态：
绕物体坐标系三个轴的旋转，由于物体旋转过程中坐标轴随着物体做相同的转动,所以称为动态。

物体的任何⼀种旋转都可分解为分别绕三个轴的旋转，但分解⽅式不唯⼀.unity中的欧拉角有两种方式可以解释: 
  1. 当认为顺序是yxz时（其实就是heading - pitch - bank），是传统的欧拉角变换，也就是以物体自己的坐标系为轴的。
  2. 当认为顺序是zxy时（roll - pitch - yaw），也是官方文档的顺序时，是以惯性坐标系为轴的。后者比较直观一些，但其实两者的实际效果是一样的，只是理解不一样。

****
# 3.生命周期函数
**初始化阶段**: 
- `Awake()`   :在**脚本实例被创建时**调用，无论脚本是否启用
- `OnEnable()`:在脚本启用时调用
- `Start()` : 在脚本启用后，**第一次 Update 之前**调用
  
**更新阶段**:
- `FixedUpdate()`:按照**固定的时间间隔**调用,（默认 0.02 秒，可在 Time.fixedDeltaTime 中设置）
- `Update()`: 每帧调用一次
- `LateUpdate()`:在 Update() 之后调用，每帧调用一次。

**渲染阶段**
- `OnGUI()` : 每帧调用多次，用于渲染 GUI 元素。

**销毁阶段**
- `OnDisable()`:在脚本禁用时调用
- `OnDestroy()`: 在脚本被销毁时调用

**总结:**
- 初始化阶段：Awake() → OnEnable() → Start()
- 更新阶段：FixedUpdate() → Update() → LateUpdate()
- 渲染阶段：OnGUI()
- 销毁阶段：OnDisable() → OnDestroy()

****
# 4.Unity的协程
协程不是线程,协程的实现原理是迭代器,而迭代器的底层是状态机

## 4.1协程的执行过程
- 执行StartCoroutine()时,程序会立即进入相关的协程方法
- 在遇到yield return语句之前,协程和普通函数无异,顺序执行里面的代码
- 遇到yield return时,这行代码是 "暂停点"，协程会在这里暂停执行
- 此时，程序会立刻跳回到StartCoroutine()后面的代码继续执行
- 协程的后半部分（yield 之后的代码）被暂时搁置
- Unity 主线程继续处理其他事情（渲染、输入、其他脚本等）
- 当yield return XXX指定的条件满足时
- Unity 会在合适的时机（通常是帧更新时）恢复协程，从上次暂停的yield语句后面继续执行剩余代码

## 4.2挂起的程序什么时候执行?
协程主要是Update()方法之后,LateUpdate()之前调用.

**具体流程**
1. 每帧先执行所有Update()
2. 然后检查所有挂起的协程：
   - 如果yield return XXX的条件满足（比如等了 1 秒、等了一帧、等的对象加载完成），就执行该协程yield后面的代码
   - 如果条件没满足，继续挂起，等下一帧再检查
3. 最后执行所有LateUpdate()

**协程受什么状态影响？**
协程的生命周期和载体（GameObject）绑定，和 MonoBehaviour 脚本的状态无关：

1. 对协程没影响的操作：
    - 关闭脚本的enabled = false：
    协程会继续执行（因为协程本质是 Unity 引擎管理的任务，不是脚本自身的方法）。
2. 会让协程完全停止的操作：
    - 把 GameObject 设置为SetActive(false)：
    此时整个对象被 “冻结”，协程会立刻停止，且即使之后再激活对象，停止的协程也不会恢复（必须重新调用StartCoroutine）。
    - 销毁 GameObject 或脚本（Destroy）：
    协程会随载体一起被销毁，直接终止。

总结 : 协程每帧在Update()和LateUpdate()之间 “插队” 执行（检查条件并恢复），它的生死只看所在 GameObject 是否激活 / 存在，和脚本自身是否启用无关。

****
# 5.RectTransform 和 Transform 的区别
## 5.1继承关系
- Transform 是基类：所有游戏对象（GameObject）都必须包含的组件，负责控制对象的位置、旋转、缩放。
- RectTransform 是子类：继承自 Transform，仅用于 UI 元素，在 Transform 基础上增加了 UI 特有的布局控制功能。
## 5.2适用场景
- Transform：用于 3D 物体、非 UI 的 2D 物体（如 Sprite）等不在 Canvas 下的对象，控制其在 3D 世界空间或 2D 世界空间中的位置。
- RectTransform：仅用于 Canvas 下的 UI 元素（如 Button、Image、Text 等），控制其在 UI 画布中的位置和布局。
（只要对象在 Canvas 层级下，无论 2D/3D 模式，都会自动使用 RectTransform 而非 Transform）
## 5.3坐标与布局控制(核心区别)
1. 坐标系统不同
   - **Transform：**
   使用 position（世界坐标）或 localPosition（相对于父对象的本地坐标），基于父对象的中心点计算位置。
   - **RectTransform：**
   使用 anchoredPosition（2D 坐标，忽略 Z 轴）或 anchoredPosition3D（3D 坐标），位置是相对于自身锚点（Anchor）的偏移，与父对象的中心点无关。

2. 锚点（Anchor）是 RectTransform 的核心特性
     - 锚点是 RectTransform 独有的布局控制方式，由「最小锚点（min）」和「最大锚点（max）」组成，取值范围均为 0~1（对应父对象的左下到右上）。
     - 作用：决定 UI 元素如何跟随父对象的大小 / 位置变化：
        - 当 min = max 时：锚点是一个点，UI 元素会固定在该点，位置由 anchoredPosition 控制（相对于锚点的偏移）。
        - 当 min ≠ max 时：锚点形成一个矩形区域，UI 元素会自动拉伸填充这个区域（此时 sizeDelta 控制额外的大小偏移）。

****
# 6.碰撞器和触发器的区别？
碰撞器用于**物理交互，产生碰撞响应，触发 OnCollision 系列事件**。
触发器用于**逻辑检测，不产生物理响应，触发 OnTrigger 系列事件**。

****

# 7.物体发⽣碰撞的必要条件？
**碰撞物体(主动)**: 必须带有**collider碰撞器和rigibody刚体**属性或者⼈物控制器(人物控制器包括前面两个)
**被撞物体(被动)**: 必须带有Collider


| **特性**            | **碰撞物体**                     | **被撞物体**                     |
|---------------------|----------------------------------|----------------------------------|
| **刚体**            | 必须附加刚体（Dynamic或Kinematic）| 可以没有刚体，或刚体为Kinematic |
| **运动**            | 主动移动或受外力影响             | 通常静止，被动接受碰撞           |
| **物理效果**        | 施加力或反弹                     | 接收碰撞，不主动施加力           |
| **示例**            | 玩家角色、抛出的球               | 地面、墙壁                       |

****
# 8.CharacterController和Rigidbody的区别？
**Rigidbody（刚体）：**
完全依赖 Unity 物理引擎，模拟真实世界的物理规律（重力、碰撞、摩擦力等），适合需要真实物理交互的物体（如掉落的箱子、弹球、受外力推动的物体）。

**CharacterController（角色控制器）：**
是一种 “简化的物理组件”，手动控制移动逻辑，不完全遵循真实物理（如重力需要手动实现），专为角色移动设计（如玩家控制的人物、NPC）。

- 用Rigidbody当你需要：
    - 物体受重力、碰撞力影响（如被炸开的石块）
    - 模拟真实物理效果（如 ragdoll 布娃娃系统）
    - 物体之间有复杂的物理交互（如推箱子谜题）
- 用CharacterController当你需要：
    - 精确控制角色移动（如第三人称 / 第一人称游戏主角）
    - 避免角色被意外物理力干扰（如不想被敌人撞飞）
    - 简单处理斜坡、台阶等地形（无需复杂物理调试）

****
# 9.物体发⽣碰撞时，有⼏个阶段，分别对应的函数？
三个阶段，OnCollisionEnter/Stay/Exit函数
****
# 10.物体发⽣碰撞时，⼏种施加压⼒的⽅式，描述出来？ 
rigidbody.AddForce/AddForceAtPosition,都是rigidbody的成员函数 
****
# 11.Unity3d提供了⼏种光源，分别是什么？ 
共4种，
- DirectionalLight,平行光,没有衰减,模拟太阳,月亮等全局光源
- PointLight,点光源,球形光照范围,有衰减,模拟灯光等
- SpotLight,聚光灯,锥形范围,有衰减,模拟手电等
- AreaLight,区域光,矩形区域发射光线,有衰减,模拟窗户透进的自然光,⽤于烘焙
****
# 12.物理更新⼀般在哪个系统函数⾥？ 
在FixedUpdate中。FixedUpdate**可以保持固定的时间间隔调用**，所以某些需要在时间上精确模拟的任务就需要放在FixedUpdate中。
****
# 13.移动相机动作在哪个函数⾥，为什么在这个函数⾥。 
LateUpdate，是在所有的update结束后才调⽤，⽐较适合⽤于命令脚本的执⾏。官⽹上例⼦是摄像机的跟随，都是所有的update操作完才进⾏摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视⻆⾥还未有⻆⾊的空帧出现。
****
# 14.简述⼀下Prefab的⽤处？ 
在游戏运⾏时实例化，prefab相当于⼀个模板，对你已经有的素材、脚本、参数做⼀个默认的配置，以便于以后的修改，同事prefab打包的内容简化了导出的操作，便于团队的交流。
***
# 15.简述⼀下对象池,你觉得在FPS游戏⾥哪些东⻄适合使⽤对象池？ 
对象池就存放需要被反复调⽤资源的⼀个空间，⽐如游戏中要常被⼤量复制的对象，⼦弹，敌⼈，以及任何重复出现的对象。
***
# 16.OnEnable、Awake、Start运⾏时的发⽣顺序？哪些可能在同⼀个对象周期中反复的发⽣？ 
Awake–>OnEnable->Start，OnEnable在同⼀周期中可以反复地发⽣! 

***
# 17.MeshRender中 material 和shared material，这两个接口有什么区别
- 修改**sharedMaterial**将**改变所有物体**使⽤这个材质的外观，并且也**改变储存在⼯程⾥的材质设置**。 
- 不推荐修改由sharedMaterial返回的材质。如果你想修改渲染器的材质，使⽤material替代。
- **`material` 属性**
    - 返回或设置当前 MeshRenderer 使用的材质。
    - 每次访问 material 时，Unity 会**自动创建一个新的材质实例**（即使材质本身是共享的）。
- **`sharedMaterial` 属性**
    - 返回或设置当前 MeshRenderer 使用的共享材质。
    - 直接访问材质资源，**不会创建新的材质实例**。


| **特性**            | **`material`**                            | **`sharedMaterial`**                     |
|---------------------|------------------------------------------|------------------------------------------|
| **材质实例化**      | 每次访问都会创建新的材质实例。           | 直接引用材质资源，不会创建新实例。       |
| **修改影响范围**    | 仅影响当前物体。                         | 影响所有使用该材质的物体。               |
| **内存开销**        | 较高，频繁访问会导致多个材质实例。       | 较低，不会创建新的材质实例。             |
| **适用场景**        | 需要单独修改某个物体的材质时。           | 需要全局修改材质或仅读取材质属性时。     |

***
# 18.如何安全的在不同⼯程间安全地迁移asset数据？三种⽅法 
1. 将Assets和Library⼀起迁移 
2. 导出包package 
3. ⽤unity⾃带的assets Server功能 
***
# 19.TCP/IP协议栈各个层次及分别的功能？ 
- **⽹络接⼝层**：这是协议栈的最低层，对应OSI的物理层和数据链路层，主要完成数据帧的实际发送和接收。 
- **⽹络层**：处理分组在⽹络中的活动，例如路由选择和转发等，这⼀层主要包括IP协议、ARP、ICMP协议等。 
- **传输层**：主要功能是提供应⽤程序之间的通信，这⼀层主要是TCP/UDP协议。 
- **应⽤层**：⽤来处理特定的应⽤，针对不同的应⽤提供了不同的协议，例如进⾏⽂件传输时⽤到的FTP协议，发送email⽤到的SMTP等。 

****
# 20.渲染管线
[参考文章](https://zhuanlan.zhihu.com/p/627201581)
**实现将3D场景转换成2D图像的过程的流水线就叫渲染管线**
- **划分渲染管线**
  - 首先需要区分渲染管线的**功能性阶段**和**GPU硬件管线阶段**区分。
  - **功能性阶段是概念性的**，是我们为了给一个渲染流程进行基本的功能划分而提出来的。
  - 而**GPU流水线**则**是硬件层上真正用于实现上述功能的**流水线。
- 渲染管线一般分为如下四个功能性阶段：**应用阶段**、**几何阶段**、**光栅化阶段**和**像素阶段**。

## 应用阶段
  - 在**CPU**上进行,应用阶段**通过索引将顶点装配在一起**，构成图元传递给几何阶段。
  - **DrawCall**也是在应用阶段产生的

## 几何阶段
- 在**GPU**上运行,**处理**应用阶段发送的**渲染图元**，负责大部分的逐三角性和逐顶点操作。
- 几何阶段的一个重要任务就是**把顶点坐标变换到屏幕空间**中 ，再交给光栅器进行处理。
- 这一阶段将会**输出屏幕空间的二维顶点坐标**、**每个顶点对应的深度值**、**着色等相关信息**，并传递给光栅化阶段。
- 几何阶段可以细分为4个子阶段：**顶点着色阶段**，**投影阶段**，**裁剪阶段**和**屏幕映射阶段**。
    - ### 顶点着色阶段
      计算顶点位置，传递后续管线需要的用来插值的数据。
      其中，顶点从模型空间通过**MVP变换**到齐次裁剪空间。
    - ### 裁剪
    - ### 屏幕映射阶段
      将处于NDC空间图元的3D顶点的**xy坐标转换到屏幕坐标系**下。

## 光栅化阶段
- 在**GPU**上执行。目标是**找到处于图元(三角形)内部的所有像素**，进而**将2D坐标顶点转为屏幕上的像素**，每个像素附带**深度**和**其他着色信息**，它们一并传入pixel。
- 光栅化阶段分为两个子阶段：**三角形设置**和**三角形遍历**。

## 像素阶段
- 在**GPU**上执行,主要处理光栅化阶段发送过来的在图元内部的片元序列。GPU会对每个片元进行像素操作，如颜色和深度的计算、纹理采样、混合等。最终，这些像素被组合成最终的图像。
- 像素阶段可以分为两个子阶段：**像素着色阶段**和**合并阶段**。
  - ### 像素着色阶段
    - 使用光栅化阶段传递的插值后的数据以及纹理计算像素颜色。
  - ### 合并阶段
****
# 21.如何优化内存?
1. 压缩自带类库
2. 将暂时不用的以后还会使用的物体隐藏起来,而不是Destroy掉
3. 释放AssetBundle占用的资源
4. 降低模型的片面数,降低模型的骨骼数量,降低贴图的大小
5. 使用光站贴图,使用多层次细节(LOD),使用着色器(Shader),使用预设(Prefab)
****
# 22.动态加载资源的方式?
1. Resource.Lord()
2. AssetBundle
****
# 23.什么叫链条关节?
Hinge Joint,
可以模拟两个物体之间用一根链条连接在一起的情况,能保证两个物体在一个固定距离内部相互移动而不产生作用力,但达到固定距离后会产生拉力
****
# 24.物体自身旋转使用的函数?
transform.rotate()
****
# 25.unity提供的用于保存和读取数据的类是?
PlayerPrefs类

举例: 保存和读取整形数据
PlayerPrefs.SetInt(),PlayerPrefs.GetInt()
****
# 26.在场景中放置多个Camera并同时属于激活状态会怎样?
游戏界面可以看到多个摄像机的混合
****
# 27.如何销毁一个UnityEngine.Object及其⼦类？ 
Destroy()
****
# 28.游戏动画的种类及其原理?
1. 关节动画
2. 骨骼动画
3. 单一网络模型动画(关键帧动画)

**关节动画**: 把⻆⾊分成若⼲独⽴部 
分，⼀个部分对应⼀个⽹格模型，部分的动画连接成⼀个整体的动画，⻆⾊⽐较灵活，Quake2中使⽤这种动画； 
**⻣骼动画**: ⼴泛应⽤的动画⽅式，集成了以上两个⽅式的优点，⻣骼按⻆⾊特点组成⼀定的层次结构，有关节相连，可做相对运动，⽪肤作为单⼀⽹格蒙在⻣骼之外，决定⻆⾊的外观； 
**单⼀⽹格模型动画**: 由⼀个完整的⽹格模型构成，在动画序列的关键帧⾥记录各个顶点的原位置及其改变量，然后插值运算实现动画效果，⻆⾊动画较真实。 
****
# 29.请描述为什么Unity3d中会发⽣在组件上出现数据丢失的情况 
答： ⼀般是组件上绑定的物体对象被删除了
***
# 30.LOD的概念和优缺点?
LOD(Level of detail)多层次细节，是最常⽤的游戏优化技术。它按照模型的位置和重要程度决定物体渲染的资源分配，降低⾮重要物体的⾯数和细节度，从⽽获得⾼效率的渲染运算。
***
# 31.mono和.Net?
mono是.Net的开源平台工具,因为.Net只能在Win系统下运行,而Mono可以实现跨平台编译运行
***
# 32.Image和RawImage的区别
- Image比rawImage更消耗性能
- Image只能使用Sprite属性的图片，但是RawImage是各种图片设置都可以使用
- Image适合放一些有操作的图片，裁剪平铺旋转什么的，针对Image Type属性
- RawImage就放单独展示的图片就可以了，性能就会比Image好很多
***
# 33.U3D中⽤于记录节点空间⼏何信息的组件名称
Transform
***
# 34.向量的点乘、叉乘以及归⼀化的意义？ 
1. 点乘描述了两个向量的相似程度，结果越⼤两向量越相似，还可表示投影 
2. 叉乘得到的向量垂直于原来的两个向量 
3. 标准化向量：⽤在只关系⽅向，不关⼼⼤⼩的时候 
***
# 35.动态合批与静态合批
**动态**: 如果动态物体共用的相同的材质,那么unity会自动对这些物体进行批处理,动态合批是自动的,但是限制很多
**静态**: 自由度较高,限制少,可能会占用更多的内存,而且经过静态批处理后所有物体都不再移动了
***
# 36.什么是LightMap?
就是指在三维软件⾥实现打好光，然后渲染把场景各表⾯的光照输出到贴图上，最后⼜通过引擎贴到场景上，这样就使物体有了光照的感觉。
***
# 37.射线检测碰撞物的原理是？
射线是3D世界中⼀个点向⼀个⽅向发射的⼀条⽆终点的线，在发射轨迹中与其他物体发⽣碰撞时，它将停⽌发射。
***
# 38.客户端和服务器交互有几种方式?
- socket(套接字),实现服务器与客户端的物理连接,并进行数据运输,主要有UDP和TCP两个协议.处于网络协议的传输层
- http协议传输的主要有http协议和基于http协议的Soap协议（web service）,常⻅的⽅式是 http 的 post 和 get 请求，web 服务。
***
# 39.Unity中，照相机的Clipping Planes的作⽤是什么？调整Near、Fare两个值时，应 该注意什么？ 
剪裁平⾯ 。从相机到开始渲染和停⽌渲染之间的距离。
***
# 40.如何在Unity3D中查看场景的⾯数，顶点数和Draw Call数？如何降低Draw Call数？ 
在Game视图右上⻆点击Stats。降低Draw Call 的技术是Draw Call Batching
***
# 41.unity在移动设备上的一些优化资源的方法
1. 用AssetBundle,实现资源分离和共享,将内存控制在200M之内,同时也可以实现资源的在线更新
2. 降低顶点数
3. 只使用一盏动态光,不使用阴影和光站探头
4. 粒子系统是非常占用CPU的,剪裁粒子系统
5. 合并同时出现的例子系统
6. 自己实现轻量级的粒子系统
7. 把不需要骨骼动画和动作过渡的地方全部使用Animation,骨骼数量控制在30跟以下
8. Animation出视野不更新
9. 删除无意义的Animation
10. Animator的初始化很耗时间,粒子上尽量不用Animator
11. 除主角外都不要用骨骼跟踪
12. 绝对禁⽌掉那些不带刚体带包围盒的物体（static collider ）运动 
13. NGUI的代码效率很差，基本上runtime的时候对cpu的贡献和render不相上下 
14. 每帧递归的计算finalalpha改为只有初始化和变动时计算 
15. 去掉法线计算 
16. 不要每帧计算viewsize 和windowsize 
17. filldrawcall时构建顶点缓存使⽤array.copy 
18. 代码剪裁：使⽤strip level ，使⽤.net2.0 subset 
19. 尽量减少smooth group 
20. 给美术定⼀个严格的经过科学验证的美术标准，并在U3D⾥⾯配以相应的检查⼯具
***
# 42. 将Camera组件的ClearFlags选项选成Depth only是什么意思？有何⽤处？
仅深度，该模式⽤于对象不被裁剪。
***
# 43.如何让已经存在的GameObject在LoadLevel后不被卸载掉？
```css
void Awake() 
{ 
  DontDestroyOnLoad(transform.gameObject); 
}
```
***
# 44.在编辑场景时将GameObject设置为Static有何作⽤？
设置游戏对象为static,当这些部分被静态物体挡住不可见时将会剔除(或禁用)网格对象,因此,场景里所有不会动的物体都应该标记为static
***
# 45.有A和B两组物体，有什么办法能够保证A组物体永远⽐B组物体先渲染？
把A组物体的渲染对列小于B物体的渲染队列
***
# 46.将图⽚的TextureType选项分别选为Texture和Sprite有什么区别？
- Sprite作为UI精灵使⽤
- Texture作⽤模型贴图使⽤
***
# 47.什么是DrawCall？DrawCall⾼了⼜什么影响？如何降低DrawCall？
Unity中，每次引擎准备数据并通知GPU的过程称为⼀次Draw Call。DrawCall越⾼对CPU的消耗就越⼤

降低DrawCall的⽅法： 
- Dynamic Batching (动态合批)
- Static Batching (静态合批)
- ⾼级特性Shader降级为统⼀的低级特性的Shader。
***
# 48.Unity跨平台的原理
Unity 的跨平台能力主要依赖于 C# 代码的编译和运行方式，其核心流程经历了两个阶段：
   1. 早期：基于 Mono 虚拟机（JIT/AOT）
   2. 现在：基于 IL2CPP（AOT）

**早期方案: Mono虚拟机**
*(1) C# -> CIL*
  - CIL可以在任何支持Mono/.Net的平台上运行

*(2) CIL -> 机器码（JIT 或 AOT）*
  - Unity 使用 Mono 运行时，通过两种方式将 CIL 转换成目标平台的机器码：
  - JIT（Just-In-Time，即时编译
    - 运行阶段：在程序运行时，Mono 虚拟机动态将 CIL 编译成当前 CPU 能执行的机器码。
    - 优点：灵活，适合支持动态代码生成的平台（如 Windows、Android）。
    - 缺点：启动稍慢（需要编译），且某些平台（如 iOS）禁止 JIT 编译（出于安全考虑）。

  - AOT（Ahead-Of-Time，预先编译）
    - 构建阶段：在打包时，直接提前将 CIL 编译成目标平台的机器码（如 iOS 的 ARM 指令）。
    - 优点：运行更快，兼容 iOS 等限制 JIT 的平台。
    - 缺点：无法动态生成代码（如 System.Reflection.Emit 在 AOT 下可能失效）。

Mono 的局限性
- 性能较低：Mono 虚拟机的优化有限，尤其是移动端。
- 兼容性问题：不同平台的 Mono 版本可能不一致，导致行为差异。
- iOS 限制：苹果禁止 JIT，只能用 AOT，但 Mono 的 AOT 支持不够完善。

**现代方案：IL2CPP（AOT）**
*(1)C# → CIL*
和之前一样

*(2)CIL → C++（IL2CPP 转换）*
- Unity 使用 IL2CPP 工具，将 CIL 代码转换成 标准 C++ 代码。
- 优点：
  - C++ 几乎可以在所有平台编译，兼容性极强。
  - C++ 可以被各平台的原生编译器（如 LLVM、MSVC、GCC）高度优化，运行效率更高。

*（3）C++ → 目标平台机器码*
- 使用平台特定的编译器（如 iOS 用 Xcode 的 Clang，Android 用 NDK 的 GCC/Clang）将 C++ 编译成最终的可执行文件。

- AOT 编译：所有代码在运行前就已经编译成机器码，没有 JIT 开销，且符合 iOS 的安全策略。
***
# 销毁的时候会调用 ondisable吗?
**销毁的时候会调用 OnDisable()**
- 销毁对象时：会先调用 OnDisable()，再调用 OnDestroy()。
- 禁用对象时：只会调用 OnDisable()。
- 启用对象时：会调用 OnEnable()。

****
# 对象池的作用
对象池是一种设计模式，用于管理和重用对象，而不是频繁地创建和销毁对象。它通过预先创建一组对象并存储在池中，当需要时从池中获取对象，使用完毕后将对象归还到池中，而不是直接销毁。

*作用*
- **减少内存开销**：避免频繁创建和销毁对象，减少内存分配和垃圾回收（GC）的压力。
- **提高性能**：对象复用减少了实例化和初始化的时间，特别适合需要频繁创建和销毁对象的场景（如子弹、敌人、特效等）。
- **优化资源管理**：集中管理对象的生命周期，避免资源泄漏或过度占用内存。
- **适用于高频操作**：在游戏开发中，对象池常用于管理子弹、敌人、粒子特效等需要频繁生成和销毁的对象。

*****
# UGUI的图集作用
避免你每次用到图片的时候去查找图片资源，把一些图片打在一个图集上面，需要某个图片的时候就直接改变uv就行了，减少了drawcall。

****
# drawcall是什么?
Draw Call 是 **CPU 向 GPU 发送**的绘制指令，**用于渲染**一个或多个物体。每次 Draw Call 都会触发 GPU 执行一次绘制操作。

****

# NavMesh实现原理

***
# 帧同步与状态同步
## 状态同步
- 状态同步是**大型网游**普遍会采用的一种同步技术，它特点是**客户端会向服务器发送一些指令**，比如在角色扮演类中从游戏的NPC那里买一些物品时，客户端会向服务器发送一个指令，指令中包括玩家ID、购买商品的ID号、商贩NPC的ID号，将这些信息传到服务器后，服务器会计算玩家的金钱是否足够，当前所处位置是否在NPC身边、NPC是否有这个物品等等
- 服务器会做很多**校验**，校验完以后才能确定玩家是否能购买物品，如果不能买服务器就会给客户端下发一个交易失败的指令，可以购买服务器则会下发玩家在购买完商品以后，背包里面增加了哪些东西，或者减少了哪些东西的消息
- 状态同步的特点就是状态同步**发送的是一些操作，接收的是一些状态**，这些状态数据可能会很大，所以在同步时所要同步的数据量也会比较大，状态同步的的好处就是**安全性比较好，反作弊能力比较强**
## 帧同步
- 帧同步的特点可以总结为六个字：**发操作、收操作**，也就是说**客户端发送的是操作，接收的也是操作**，**服务器**在接收到客户端发送的操作后，**不会做任何运算**，而是**以广播**的形式将这个操作发送给同一房间里的所有玩家
- 其他玩家在接收到的操作后就会产生相应的画面表示，比如玩家1发射了一颗子弹，那么在玩家2的客户端上就应该实例化一颗子弹出来，然后让颗子弹以一定的速度朝某一个方向发射，这就是帧同步的一个特点
- 帧同步**将所有运算都放在客户端去做**其实有一个非常大的好处，就是它的运算非常简洁因为就像在开发一个客户端游戏一样，服务器不需要做什么太多的工作，如果你是一个优秀的客户端开发者就可以比较轻松的实现一个相对比较完善的帧同步框架

### 在帧同步游戏中，处理不同设备浮点精度差异的方案如下：
- **使用定点数**
  - 将浮点数转换为定点数，确保所有设备计算结果一致。
- **限制浮点运算**(注意是限制,不是禁用)
  - 避免使用高精度浮点运算，采用近似计算或查表法。
***
# 设计模式
## 单例模式
- 单例模式是指在内存中**只会创建且仅创建一次对象**的设计模式。
- 在程序中多次使用同一个对象且作用相同时，为了防止频繁地创建对象使得内存飙升，单例模式可以**让程序仅在内存中创建一个对象**，**让所有需要调用的地方都共享这一单例对象**。
- 单例模式有两种类型：
  - 懒汉式：在**真正需要使用**对象时才去创建该单例类对象
  - 饿汉式：在**类加载**时已经创建好该单例对象，等待被程序使用

## 原型模式
- 原型模式就是在内存中**先保存一份作为原型**, 如果需要直接进行**复制**创建, Unity通过Instantiate创建物体, 实际上就是在克隆物体, 是浅拷贝
  - 浅拷贝：**只复制对象的基本数据类型**，对于引用类型的字段，**只复制引用地址**。
  - 深拷贝：不仅**复制对象的所有值**，还**递归地复制所有引用对象**，创建独立的副本。

## 建造者模式
- 建造者模式是一种创建型设计模式，它将复杂对象的构建过程与对象的表示分离，使得同样的构建过程可以创建不同的对象。建造者模式特别适用于那些构建步骤复杂且具有多种配置的对象。
- 如果一个对象的创建步骤非常复杂，需要按照一定的顺序**构建多个部件**，建造者模式可以帮助你将这些步骤组织清晰，避免直接调用复杂的构造函数。

## 观察者模式
- 观察者模式定义了一种**一对多**的依赖关系，让**多个观察者对象同时监听某一个主题对象**。**这个主题对象在状态发生变化时，会通知所有观察者对象**，让他们能够更新自己。

***
# unity序列化规则

- 支持的类型：基本类型（如int、float、string）、Unity引擎类型（如Vector3、Color）、数组、**List**、可序列化的自定义类。

- 不支持的类型：**Dictionary**、**HashSet**、静态字段(static)、属性、**委托和事件**。

- 字段的可见性: 
  - public字段:默认会被序列化。可以使用`[NonSerialized]`或`[HideInInspector]`来取消public的序列化;
  - private、protected和internal字段：默认不会被序列化。可以使用`[SerializeField]`强制序列化。

***
# 删除游戏对象（GameObject）的方法
- `Destroy`
  - 删除一个游戏对象、组件或资源。
  - 如果指定了延迟时间t，对象会在t秒后被删除。
  - 特点:
    - 延迟删除：Destroy不会立即删除对象，而是将对象标记为“待删除”，在下一帧或指定时间后才会真正删除。
    - 线程安全：可以在主线程以外的线程中调用。
-  `DestroyImmediate`
   -  立即删除一个游戏对象、组件或资源。
   -  特点：
      -  立即删除：DestroyImmediate会立即删除对象，而不是等待下一帧。
      -  线程不安全：只能在主线程中调用。

***
