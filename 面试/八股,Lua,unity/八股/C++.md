[TOC]

****
# 1.C++内存布局？(高频)
- **栈区：** 存放函数的`局部变量`、`函数参数`、`返回地址`等，**由编译器自动分配和释放**。
- **堆区：** 动态申请的内存空间，就是**由 malloc 分配**的内存块，**由程序员控制**它的分配和释放，如果*程序执行结束还没有释放*，*操作系统会自动回收。*
- **全局/静态存储区（.bss 段和 .data 段）：** 存放**全局变量**和**静态变量**，程序运行结束操作系统**自动释放**，**未初始化**的放在 **.bss 段**中，**初始化**的放在 **.data 段**中。
- **常量存储区（.data 段）：** 存放的是**常量**，不允许修改，程序运行结束**自动释放**。
- **代码区（.text 段）：** 存放**代码**，不允许修改，但**可以执行**。编译后的二进制文件存放在这里。

****
# 2.static关键字的作用?
static不需要初始化,默认为0

- 全局静态变量: 位于静态存储区,程序运行期间一直存在,对外部不可见
- 局部静态变量: 位于静态存储区,在局部作用域可以访问,离开作用域后static变量仍然存在,但无法访问
- 静态函数: 即在函数定义之前加上static,之后便不能为外部类访问
- 类的静态成员: 可以实现多个不同实例的数据共享,类的静态存储变量是可以修改的.通过<类名>::<静态成员>进行访问
- 类的静态函数: 不能调用非静态成员,最好通过类名调用<类名>::<静态成员函数>
***
# 3.类型转换
- `static_cast`
用于各种**隐式转换**，比如`void*`转`ptr*`
- `const_cast`
用来**移除变量的cons**t或volatile限定符
- `reinterpret_cast`
允许将任何指针转换为任何其他指针类型，并不安全。
- `dynamic_cast`
**安全**的**向下进行类型转换**。**只能用于含有虚函数的类**，只能转指针或引用。

## c++的四种类型转换哪些是在运行时进行？哪些是在编译时进行？
- 编译时：static_cast、const_cast、reinterpret_cast。
- 运行时：dynamic_cast。

### 对于dynamic_cast在运行时进行的原因
- 在运行时**检查对象的实际类型**。如果转换失败，返回 `nullptr`（对于**指针**）或抛出 `std::bad_cast` 异常（对于**引用**）。
****
# 4.static_cast和reinterpret_cast的区别?
1. static_cast指向void\*或来自void*的指针保留地址.也就是说,在以下a,b,c都指向同一个地方
    ```cpp
    int* a = new int();
    void* b = static_cast<void*>(a);
    int* c = static_cast<int*>(b);
    ```
2. reinterpret_cast保证只有当指针转换为不同的类型,然后将其转恢复为原来类型的时候,你才能获得原始值.如下代码,a和c有相同的值,但是b就不一定了
    ```cpp 
    int* a = new int();
    void* b = reinterpret_cast<void*>(a);
    int* c = reinterpret_cast<int*>(b);
    ```

**总结**:
 - 对于void*的转换,首选static_cast
 - 对于模糊类型的转换,应该使用reinterpret_cast
****
# 5.C++指针和引用的区别?
1. 指针有自己的内存地址,占四个字节(32位),而引用只是个别名,没有专门的内存地址
2. 指针可以被初始化nullptr,而引用必须指向一个已有的对象
3. 作为参数传递,指针是需要解引用的,而直接修改引用会改变原对象
4. 指针可以多级,但是引用就一级
5. 如果返回动态内存分配对象,必须用指针,否则可能引起内存泄漏
****
# 6.int \*p[n] 和int (\*p)[n]以及int \*p()和int (\*p)() 的区别。
- int* p[n]表示p为指针数组,可以理解为int* (p[n])
- int (\*p)[n] 表示p为二维数组指针。int (\*p)[10]表示行指针，指向一行有10个元素的指针，其类型与二维数组名相同。如，可以这样使用。
    ```cpp
    int a[2][10];
    int (*p)[10]=a; //p指向数组a的首行。
    ```
- int* p()表示p为函数,返回类型是int*
- int(*p)()表示函数指针,函数原型是int func(),函数指针不能++或--
****
# 7.volatile关键字有什么用?
C++的volatile和const对应,表示变脸可以被编译器未知的因素更改,比如操作系统,硬件或者其他线程. 遇到volatile,编译器不再进行优化,从而提供对特殊地址的未定访问
****
# 8.智能指针
- `shared_ptr`、`unique_ptr`、`weak_ptr`、`auto_ptr(已被弃用)`
#### shared_ptr(重点)
- 共享式指针，只有共享的最后一个引用释放资源销毁。
- 多个 shared_ptr 可以指向同一对象,可拷贝，也可以移动
- 原理：利用一个计数器，当发生使用赋值拷贝构造函数，运算符重载，作为函数返回值，或者作为一个参数传递给另外一个参数，计数+1，当shared_ptr赋新值或者销毁，计数-1.直到计数为0，调用析构函数释放对象。
##### 什么是shared_ptr的循环引用问题，如何解决？
- 某对象存在一个shared_ptr类型的指针ptr，A的ptr指向B，B的ptr指向A。两个智能指针对象指向A，B，再加上他们的ptr分别指向B，A，所以引用计数均为2，造成了循环引用，谁也不会被释放。
- 三种解决方法
  - 当剩下最后一个引用时，需要手动打破循环引用释放对象；
  - 当A的生存周期超过B的生存周期，B改为一个普通指针指向A；
  - **将其中一个共享指针改为弱指针weak_ptr(重点)**
#### unique_ptr
- 独占式的指针，离开 unique_ptr 对象的作用域时，会自动释放资源。
- 同一时间只有一个 unique_ptr 可以指向特定对象,几乎没有额外内存开销,不可拷贝，但可以移动（std::move）
##### unique_ptr是如何实现独占式指针？
- 由于**指针或引用在离开作用域是不会调用析构函数的**，但对象在离开作用域会调用析构函数。unique_ptr**本质是一个类**，将**复制构造函数**和**赋值构造函数声明为delete**就可以实现独占式，只允许移动构造和移动赋值。
****
# 9.拷贝构造函数
拷贝构造函数用于用一个已存在的对象来初始化一个新对象。它在对象复制时被自动调用。

`基本语法`

  ```cpp
      class MyClass {
      public:
          // 拷贝构造函数
          MyClass(const MyClass& other) {
              // 拷贝逻辑
          }
      };
  ```
如果类没有定义拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数，它执行浅拷贝

## 深拷贝与浅拷贝
- 浅拷贝就是增加了一个新指针指向原来的地址,那么改变原有对象也会改变新对象
- 深拷贝则是开辟了新的内存空间,并增加一个指向该空间的指针
****
# 10.C++类的访问权限
- public: 完全公开,任何类都可以访问
- protected: 当前类和子类可以访问
- private: 私有的,仅当前类可以访问
****
# 11.什么是注册函数?什么是回调函数?
- 回调函数
  - 回调函数是一种通过函数指针或函数对象传递的函数，它会在特定事件发生或条件满足时被调用。
- 注册函数
  - 注册函数是一种用于设置回调函数的机制，它允许将回调函数"注册"到某个系统或框架中，供后续调用。
 
说人话就是,回调函数是对函数指针的应用，用函数指针来调用一个函数,也就是说作为参数的函数都是回调函数，而注册函数则是将函数指针作为参数传进去，便于其它函数调用。
****
# 12.指针常量和常量指针
- 按顺序读就只能区分
    - const在*前是常量指针，指向可以改变，但是指向的内容不能改变。
    - *在const前是指针常量，指向不能改变，所以一定要赋初值
****
# 13.C++从源文件到可执行文件的步骤
- `预处理` -> `编译` -> `汇编` -> `链接`
## 预处理阶段:
- 编译器对文件包含关系进行检查（**头文件和宏**），将其**作相应替换**，生成`.i`文件；
## 编译阶段:
- 将**预处理**的生成文件**转化为汇编**文件`.s`;
## 汇编阶段:
- 将**汇编文件转化为二进制机器码**，对应后缀是`.obj`(Windows),`.o`(Linux);
## 链接阶段:
- 将多个目标文件及**所需要的库链接**成可执行文件，`.exe`(Windows),`.out`(Linux);
***
# 14.c++类实例的内存占用情况取决于哪些因素
- 首先**空类占1个字节**，因为**C++要求实例必须要有内存地址**
- 再看**内存对齐**，#pragma pack(n)能调节内存对齐的大小
- 虚函数的时候会有一个指向虚函数的指针，32位系统为**4字节**，64 位为**8字节**。**无论一个类有多少个虚函数，都只有这一个指针**
- 子类的大小是**本身成员变量的大小**加上**父类的大小**
***

# 15.封装,继承,多态
- **封装**: 
  封装**是将数据（属性）和操作数据的方法（行为）捆绑在一起**，并对外隐藏内部实现细节，只暴露必要的接口。
  - **核心思想**
    - 隐藏实现细节：通过访问控制（如 **private、public**），限制外部对对象内部数据的直接访问。
    - 保护数据：通过公开的方法（如 **getter 和 setter**）来**访问或修改私有数据**，确保数据的合法性。
  
- **继承**: 
  继承是指一个类（子类）可以基于另一个类（父类）创建，并**继承父类的属性和方法**，同时可以**扩展或修改父类**的行为。

- **多态**: 
  多态是指**同一个方法在不同的对象中有不同的实现方式**。它允许通过**基类的指针**或**引用调用子类的重写方法**。
    - **关键点**
        - *virtual*：**声明虚函数**，**支持多态**。
        - *override*：**显式**标记重写父类的方法。
        - 通过基类指针或引用调用子类的重写方法，实现运行时多态。

****

# 16.多态的实现原理
实现原理主要依赖于 `虚函数表（vtable）` 和 `动态绑定（Dynamic Binding）`
有虚函数的类会比没虚函数的类多`8个字节`,多出来的 8 个字节就是用来放「虚函数表」的地址。

## 什么是动态绑定?
- 虚表本质上是一个**数组**，存放着**所有虚函数的指针**。如果**父类的虚函数没有被子类改写**，那么子类虚函数表的指针就是父类对应的虚函数的指针；否则，虚表的指针是子类虚函数的指针。这个过程在程序运行过程中执行，被称为 **“动态绑定”**

- *(拓展)* 虚函数的时候会有一个指向虚函数的指针，32位系统为4字节，64 位为8字节。**无论一个类有多少个虚函数，都只有这一个指针**

****

# 17.构造函数和析构函数可以是虚函数吗？
- 构造函数**不可以是虚函数**。析构函数**可以是虚函数**。
- 虚函数表是由编译器自动生成和维护的，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，**每个对象都有一个指向虚函数的指针**（vptr）。在定义子类对象时，**vptr先指向父类的虚函数表**，在父类**构造完之后**，**子类的vptr才指向自己的虚函数表**。**因此构造函数不可以是虚函数**。
- 与构造函数不同，vptr已经完成初始化，析构函数可以声明为虚函数，且类有继承时，析构函数常常必须为虚函数。
## 为什么析构函数一般是虚函数
- 为了确保在**通过基类指针删除派生类对象时**，能够正确调用派生类的析构函数
- 当使用基类指针指向派生类对象时，**如果基类的析构函数不是虚函数，那么在删除该对象时，只会调用基类的析构函数，而不会调用派生类的析构函数**。
- 这会导致派生类中分配的资源（如动态内存、文件句柄等）无法正确释放，从而引发资源泄漏。
```cpp
class Base {
public:
    Base() { std::cout << "Base Constructor\n"; }
    ~Base() { std::cout << "Base Destructor\n"; }  // 非虚析构函数
};

class Derived : public Base {
public:
    Derived() { std::cout << "Derived Constructor\n"; }
    ~Derived() { std::cout << "Derived Destructor\n"; }
};

int main() {
    Base* ptr = new Derived();  // 基类指针指向派生类对象
    delete ptr;  // 只会调用 Base 的析构函数，Derived 的析构函数不会被调用
    return 0;
}
```
输出为:
```
Base Constructor
Derived Constructor
Base Destructor
```

***
# 18.虚表什么时候创建的?虚表是个什么样的数据结构?什么是虚指针?
- **虚表**是**编译**的时候创建的 
- **虚表**本质上是**一个存放着虚指针的数组**
- **虚指针**是在**每一个对象的头部4字节**（32位下）存的**一个指针**，用来**指向虚表**。虚表里面会继承各种虚函数，用这个指针做**偏移**能找到具体的虚函数地址，当做函数指针去调用。

****
# 19.什么是静态多态?
- 静态多态是指在**编译时**确定函数调用的具体实现，**而不是在运行时**
- 主要通过**函数重载**和**模板**来实现
- **函数重载**:
  - 函数重载是指在**同一个作用域内定义多个同名函数**，但这些函数的**参数列表**（参数类型、参数个数或参数顺序）**必须不同**。编译器根据调用时的参数类型和数量，在编译时确定调用哪个函数。
  - **为什么编译器能分辨出来?**
    - 核心是通过 `方法签名` 来区分不同的函数
    - 方法签名是用于唯一标识一个函数的特征,包括:
      - 函数名
      - 参数列表
      - 常属性

# 什么是动态多态?
- 指的是在程序**运行时**根据对象的实际类型来决定调用哪个函数。
- 它是通过**虚函数**和**继承**机制实现的，也称为运行时多态。
- 动态多态的实现依赖于**动态绑定**，即在程序运行时根据对象的实际类型确定调用哪个函数，而不是在编译时确定。
- 动态多态通常通过基类指针或引用来操作派生类对象，从而实现多态行为。

****
# 20.static
把**静态成员和静态函数**与其他的区别开记忆
- **全局静态变量**：位于静态存储区，**程序运行期间一直存在**，对外部不可见。
- **局部静态变量**：位于静态存储区，在局部作用域可以访问，**离开局部作用域之后static变量仍存在，但无法访问**。
- **静态函数**：即在函数**定义前加static**，函数默认情况下为extern，即可导出的。加了static就**不能为外部类访问**。注意不要在头文件声明static函数，因为static只对本文件有效。
- **类的静态成员**：可以**实现多个不同的类实例之间的数据共享**，且不破坏隐藏规则，不需要类名就可以访问。类的静态存储变量是可以修改的。可以通过`<对象名>::<静态成员>`进行访问。
- **类的静态函数**：**不能调用非静态成员**，只可以通过对象名调用`<对象名>::<静态成员函数>`
- **static 不需要初始化，默认为0值**。

****
# 21.讲讲malloc,new,free,delete
- **malloc**
  - `malloc` 是`C 标准库`中的函数，用于在堆（heap）上分配一块指定大小的内存。
  - `malloc` **分配的内存是未初始化的**，**内容是不确定的**。
  - 如果**分配成功**，**返回指向分配内存的指针**；如果**失败**，**返回 NULL**。
- **free**
  - `free` 是 `C 标准库`中的函数，用于释放由 `malloc` 分配的内存。
  - `free` 只能释放由 `malloc`分配的内存，**不能释放栈上的内存或未分配的内存**。
#### `malloc` 和 `free` 是 C 语言的特性，不涉及对象的构造和析构。适用于需要手动管理内存的场景。
- **new**
  - `new` 是 `C++` 中的运算符，用于在**堆上分配内存并调用对象的构造函数**。
  - `new` 不仅分配内存，**还会调用对象的构造函数**。
  - 如果分配失败，new 会抛出 `std::bad_alloc` 异常
- **delete**
  - `delete` 是 `C++` 中的运算符，**用于释放由 `new` 分配的内存并调用对象的析构函数**。
  - `delete` 不仅**释放内存**，还会**调用对象的析构函数**。
#### `new` 和 `delete` 是 C++ 的特性，支持对象的构造和析构。适用于面向对象编程，能够自动管理对象的生命周期。
****
# 22.C++STL容器有哪些
- **序列容器**:
  - `vector`(动态数组)
  - `deque`(双端队列)
  - `list`(双向链表)
-  **关联容器**:
   -  `set`
   -  `map`
- **无序关联容器**
  - `unordered_set`
  - `unordered_map`
- **容器适配器**
  - `stack`(后进先出（LIFO）)
  - `queue`(先进先出（FIFO）)
## 容器适配器
- 容器适配器是STL中的一种特殊容器,它们**基于其他底层容器**（如 `deque`、`vector` 或 `list`）实现,并**提供特定的接口和行为**。
- **常见的容器适配器**
  - **stack**
    - 基于 **deque** 实现
  - **queue**
    - 基于 **deque** 实现
****
# 23.SORT排序原理
sort采用了**快速排序**、**插入排序**和**堆排序**根据数据量大小选择合适的算法
- 当**数据量较大**，采用**快速排序**，分段递归；
  - 一旦分段后的数据量**小于一个阈值**，**改为插入排序**。
  - 为**避免递归深度过深**，达到**一定递归深度采用堆排序**。

  <center>

    ![alt text](\相关图片\image2.png)
  </center>

它**不是稳定排序**，如果需要稳定排序，可以使用 `std::stable_sort`。
## 你觉得哪些stl不能被sort排序
sort要求容器支持 **随机访问迭代器**,所以
- **不支持随机访问迭代器的容器**,如`list`,`forward_list`
- **关联容器和无序关联容器**
  - 关联容器和无序关联容器本身已经按照特定的顺序存储元素，因此不需要（也不能）使用sort 进行排序。如`set`,`map`,`unordered_set`,`unordered_map`
- **容器适配器**
  - 容器适配器通常不直接支持排序，因为它们的接口和设计目的与排序不兼容。如`stack`,`queue`
****

# 24.vector的底层原理
以下为源代码,它就是使用 **3 个迭代器**来表示的
```cpp
///_Alloc 表示内存分配器，此参数几乎不需要我们关心
template<typename _Tp, typename _Alloc>
  struct _Vector_base
  {
    struct _Vector_impl: public _Tp_alloc_type
    {
      pointer _M_start;
      pointer _M_finish;
      pointer _M_end_of_storage;
    }
  }
```
  其中，
  _M_start 指向的是 vector 容器对象的起始字节位置；
  _M_finish 指向当前最后一个元素的末尾字节；
  _M_end_of_storage 指向整个 vector 容器所占用内存空间的末尾字节。

***

# 25.vector的扩容机制
- **扩容的触发条件**
  - 当向 vector 中添加元素（例如使用 push_back）时，如果当前容量（capacity）不足以容纳新元素，vector 就会触发扩容。
- **扩容的步骤**
  - **分配新内存**：
    - vector 会分配一块更大的内存空间，通常是当前容量的 2 倍（具体倍数取决于实现，但大多数实现是 2 倍）。
  - **复制元素**：
    - 将原有元素从旧内存空间复制到新内存空间。
  - **释放旧内存**：
    - 释放旧的内存空间。
  - **更新指针和容量**：
    - 更新 vector 的内部指针，指向新的内存空间，并更新容量。
## 再说一下这个push_back和emplace_back的区别。
### push_back
- **功能**
  - 将一个元素添加到 vector 的末尾。
  - 如果元素是对象，push_back 会调用 **拷贝构造函数** 或 **移动构造函数** 来构造新元素。
- **性能开销**
  - 如果传递的是临时对象（**右值**），push_back 会调用**移动构造函数**。
  - 如果传递的是已存在的对象（**左值**），push_back 会调用**拷贝构造函数**。

### emplace_back
- **功能**
  - 在 vector 的末尾 **直接构造** 一个元素，而不是拷贝或移动。
  - 使用 **完美转发**（Perfect Forwarding） 将参数传递给元素的构造函数。
- **性能开销**
  - 直接在容器中构造元素，避免了**临时对象的构造和析构**。
  - 性能通常优于 push_back，尤其是对于复杂对象。
 
| 特性                  | `push_back`                          | `emplace_back`                      |
|-----------------------|--------------------------------------|--------------------------------------|
| **参数类型**          | 接受一个对象（左值或右值）           | 接受构造函数的参数列表               |
| **元素构造方式**      | 调用拷贝构造函数或移动构造函数       | 直接在容器中构造元素                 |
| **性能开销**          | 可能有临时对象的构造和析构开销       | 无临时对象开销，性能更高             |
| **适用场景**          | 适合添加已存在的对象                 | 适合直接构造新对象                   |

***
# 26.erase是怎么删除vector全部数据的?
```css
vec.erase(vec.begin(), vec.end());
```
- **范围删除的本质**
  - erase 并不是一个一个地删除元素，而是**一次性删除整个范围**。
  - 它会将被删除范围之后的所有元素向前移动，覆盖被删除的元素。
  - 最后，调整 `vector` 的 `size()`，但不会改变 `capacity()`。
- **迭代器的行为**
  - 在 `erase` 执行期间，`vector` 会将被删除范围之后的元素**整体向前移动**。
  - 移动完成后，所有**指向被删除元素及其之后元素**的迭代器都会失效。
  - `erase` 会返回一个指向新 `end()` 的迭代器

***
# 27.map和unordered_map有何区别？(高频)
- **map**的底层实现都是**红黑树**，插入查询删除的时间复杂度是**O(logn)**，
  **unordered_map**底层实现是**哈希表**，里面元素是**乱序排序**的，元素插入，删除，搜索的时间复杂度都是**O(1)**；
- map内部元素默认按照key 进行排序，所以支持upper_bound和lower_bound 这样的二分查找算法进行范围查询。
- 通常情况下，**std::map 比 std::unordered_map 更省空间**。

***
# 28.讲讲红黑树和哈希表(高频)
## 红黑树
- **性质**
  - 红黑树是一种自平衡的二叉搜索树（BST），它通过额外的颜色标记（红色或黑色）和旋转操作来保持树的平衡。
  - 每个节点是红色或黑色。
  - **根节点是黑色**。
  - 每个**叶子节点**（NIL 节点）**是黑色**。
  - 如果一个**节点是红色**，则它的**两个子节点都是黑色**（即没有两个连续的红色节点）。
  - **从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点**。
- **操作复杂度**
  - 插入、删除、查找：**O(log n)**。
## 哈希表
- **性质**
  - 哈希表是一种基于哈希函数的数据结构，通过将键映射到`桶`中来存储和查找数据。
  - 哈希函数：将键映射到桶的索引。
  - **冲突解决**:
    - **开放地址法**：线性探测、二次探测等。
    - **链地址法**：每个桶是一个链表或红黑树（如 C++ 的 std::unordered_map 使用链地址法）。
- **操作复杂度**
  - 插入、删除、查找：平均 **O(1)**，最坏**O(n)**
## AVL树(拓展)
- **性质**
  - AVL 树是一种自平衡二叉搜索树，它的每个节点的左右子树高度差（平衡因子）不超过 1。如果插入或删除操作导致树不平衡，AVL 树会通过旋转操作恢复平衡。
  - AVL树**可以是空树**
  - 一颗AVL树的左右子树都是AVL树
  - 一颗AVL树的左右子树高度差不超过1
  - 在定义节点时定义一个**平衡因子**，
    - 如果**左子树比右子树高一层**，那么平衡因子就为 **-1**；
    - 如果**左右子树一样高**，平衡因子就为**0**；
    - 如果**右子树比左子树高一层**，那么平衡因子就为**1**，这三种情况下AVL树的性质都没有被打破。
## 红黑树是怎么平衡的(拓展)
- 

***
# 29.快速排序(高频)
- 快速排序（QuickSort）是**不稳定**的排序算法
- 关于为什么不稳定,举例就举边界的例子;
  - 拿这个例子捋一下快排的过程就知道了`[3, 2b, 2a, 4]`
- 关于最坏时间复杂度,举例就举数组已经有序
- **平均**时间复杂度为 **O(n log n)**,**最坏**时间复杂度为 **O(n²)**。

***
# 30.数据结构的栈和堆
## 栈
- 栈就不用多说了
## 堆 
- 堆是一种**完全二叉树**，通常用于实现优先队列。按照**层序遍历**的顺序储存在一维数组中，如果该二叉 树满足父节点小于等于子节点，叫做**最小堆**（小根堆）；反之,则为大根堆.

***

# 31.memset(了解)
```cpp
void* memset(void* ptr, int value, size_t num);
```
- memset 是 C 和 C++ 标准库中的一个函数，用于将一块内存区域的内容设置为指定的值。它的定义在 <cstring>（C++）或 <string.h>（C）头文件中。
- memset 将 ptr 指向的内存区域的前 num 个字节，每个字节都设置为 value 的**低 8 位**。
  - **低 8 位**：指的是一个数据的最低有效字节（Least Significant Byte，LSB），即数据的最后 8 个二进制位。

**以下为拓展**
## memcpy
```cpp
void* memcpy(void* dest, const void* src, size_t num);
```
- **功能**
  - 将 src 指向的内存区域的前 num 个字节复制到 dest 指向的内存区域。
- **特点**
  - memcpy 假设源内存和目标内存**不重叠**。
  - 如果源内存和目标内存重叠，行为是未定义的（可能导致数据错误）。

## memmove

```cpp
void* memmove(void* dest, const void* src, size_t num);
```
- **功能**
  - 将 src 指向的内存区域的前 num 个字节复制到 dest 指向的内存区域。
  - 与 memcpy 不同，memmove 会**处理**源内存和目标内存**重叠**的情况。
- **特点**
  - memmove 会检查源内存和目标内存是否重叠。
  - 如果重叠，它会确保复制过程不会破坏数据。

## memset将一块内存区域初始化为特定的值。那你认为可以用这个去初始化一个对象吗？为什么?
**不行!!!**
- 如果对象包含虚函数，memset 会**覆盖虚表指针**（vptr）
- 如果对象包含**指针**或其他**复杂类型的成员变量**，memset 会破坏这些成员的值，可能导致**内存泄漏**或崩溃。
## memmove可以在有重叠区域完成,那他是怎么做到的?
- 如果目标内存的起始地址在源内存之前（dest < src）
  - memmove 会从源内存的起始位置开始，按正序复制数据到目标内存。
- 如果目标内存的起始地址在源内存之后（dest > src）：
  - memmove 会从源内存的末尾位置开始，按倒序复制数据到目标内存。
- 如果目标内存和源内存没有重叠：
  - memmove 的行为和 memcpy 完全一致，直接按正序复制数据。

***

# 32.strlen的原理(C语言)
- 用于计算字符串的长度
- 它的函数原型是：
  ```cpp
  size_t strlen(const char* str);
  ```
- strlen 接受一个 const char* 类型的参数，即一个指向字符串的指针。
- strlen 会从指针指向的位置开始，**逐个**字符**向后遍历**，直到遇到字符串结束符 **\0**，然后返回遍历的字符个数（不包括 \0）。

***

# 33.常用数据类型内存存储大小
| 类型 | 大小(字节) | 
|------|------|
| bool| 1|
char| 1 |
short | 2|
int | 4|
long|4|
float|4|
double| 8|

- 1字节 = 8 位
***
# 34.C++11新增的特性有哪些?
（1）auto关键字，可以自动推断出变量的类型；
（2）nullptr来代替NULL，可以避免重载时出现的问题（一个是int，一个是void*）;
（3）智能指针，那三个智能指针，对内存进行管理；
（4）右值引用，基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率；
（5）lambda表达式，可以理解为一个匿名的内联函数。
***
# 35.constexpr
- 理解constexpr前先理解什么是常量表达式

## 常量表达式

常量表达式，指的就是由多个（≥1）常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。
</br>

```cpp
// 1)
int url[10];//常量表达式
// 2)
int url[6 + 4];//常量表达式
// 3)
int length = 6;
int url[length];//错误，length是变量
```

constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。

## constexpr修饰普通变量
使该变量获得在编译阶段即可计算出结果的能力。
```cpp
#include <iostream>
using namespace std;

int main()
{
    constexpr int num = 1 + 2 + 3;
    int url[num] = { 1,2,3,4,5,6 };
    cout << url[1] << endl;
    return 0;
}
```

## constexpr修饰函数
constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。

注意，constexpr 并非可以修改任意函数的返回值。换句话说，一个函数要想成为常量表达式函数，必须满足如下 4 个条件。

1) 整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。
2) 该函数必须有返回值，即函数的返回值类型不能是 void。
3) 函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。
4) return 返回的表达式必须是常量表达式

## constexpr修饰类的构造函数
对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。

当我们想自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数。

***
# A*算法


****
# 比较刁钻的题
## LRU算法
## explict关键字
- 用于修饰类的构造函数，以防止编译器进行隐式的类型转换。


