[toc]
****
# pairs和ipairs
从遍历table上来说，**ipairs**只能只能遍历 table表的**数组部分**，**pairs**可以既可以遍历**数组部分**也可以**遍历hash部分**

**结论**：遍历table或array时，如果key是非数字，请使用pairs迭代遍历。
***
# 可变参数和多返回值
**可变参数**
Lua函数可以接受可变数目的参数，和C语言类似在函数参数列表中使用三点（...）表示函数有可变的参数。

**多返回值**
Lua函数中，在return后列出要返回的值的列表即可返回多值，
***
# Lua的基本数据类型
- `nil`,`string`,`number`,`boolean`,`thread`,`table`,`userdata`,`function`
- 重点是后四个
****
# Lua字符串的操作
1. 字符串连接：使用 .. 操作符
2. 字符串长度：使用 # 操作符或 string.len()
****
# Lua的UserData
`userdata` 是一种数据类型，用于表示由宿主程序（通常是 C 或 C++）创建和管理的外部数据。它允许 Lua 与 C/C++ 代码进行交互，扩展 Lua 的功能。
****
# Lua的闭包
闭包=函数+引⽤环境 
⼦函数可以使⽤⽗函数中的局部变量，这种⾏为可以理解为闭包！

说人话就是: 外部函数+外部函数创建的upvalue+内部函数（闭包函数）
```lua
local function foo() 
  local i = 1 
  local function bar() 
    i = i + 1 
    print(i) 
  end 
  return bar
end
local fn = foo()
print(fn()) -- 2'
```

**闭包总结**
闭包的主要作用有两个，一是简洁，不需要在不使用时生成对象，也不需要函数名；二是捕获外部变量形成不同的调用环境

**闭包原理概述：**
闭包（函数）编译时会生成原型（prototype），包含参数、调试信息、虚拟机指令等一系列该闭包的源信息，其中在递归编辑内层函数时，会为内层函数生成指令，同时为该内层函数需要的所有upvalue创建表，以便之后调用时进行upvalue值搜索

在lua中，会生成一个全局栈，所有的upvalue都会指向该栈中的值，若对应的参数离开的作用域，栈中的值也会被释放，upvalue的指针会指向自己，等待被gc

闭包运行时，会通过创建指向upvalue的指针，并循环upvalue linked list，找到所需要的外部变量进行运行

****
# UpValue
- 在lua中，会生成一个全局栈，所有的upvalue都会指向该栈中的值，若对应的参数离开的作用域，栈中的值也会被释放，upvalue的指针会指向自己，等待被gc
- 闭包运行时，会通过创建指向upvalue的指针，并循环upvalue linked list，找到所需要的外部变量进行运行
- 一个upvalue有两种状态：open和closed。当一个upvalue被创建时，它是open的，并且它的指针指向Lua栈中对应的变量。当Lua关闭了一个upvalue，upvalue指向的值被复制到upvalue结构内部，并且指针也相应进行调整


在 Lua 中，闭包对外部变量（upvalue）的引用是在闭包创建时确定的，而非每次调用时动态查找。具体来说：

**闭包创建阶段**：
当外层函数执行到内层函数定义的位置时，Lua 会分析内层函数依赖的外部变量（upvalue），并为这些变量生成一个静态的引用链（如 upvalue 链表）。
这些引用会被固化在闭包的内存结构中，形成类似“快照”的效果。即使外层函数的执行已结束，闭包仍能通过该引用链安全地访问所需的外部变量。

**闭包调用阶段**：
每次调用闭包时，直接通过预先生成的引用链访问 upvalue，无需额外遍历或重建指针。
这种设计保证了闭包的高效性，避免了因动态查找导致的性能损耗。

**共享与更新特性**：
若多个闭包共享同一 upvalue（例如嵌套函数共享父级变量），它们的引用会指向相同的内存地址，确保数据一致性。
修改 upvalue 会影响所有关联它的闭包，因为操作的是同一底层对象。

****
# Lua的table的底层原理
- **哈希表 + 数组**,根据不同需求来决定使用哪个部分。
- 如果键是一个**正整数**，并且**键的值在数组部分的范围内**（通常是连续的、密集的整数键），Lua 会尝试将其存储在**数组部分**。
- 如果键是**非正整数**（如负数、浮点数、字符串、表、函数等），或者**键是一个正整数但不在数组部分的范围内**（例如稀疏的整数键），Lua 会将其存储在**哈希表部分**。
## TValue
- 概念:
  - 它是 `Lua` 中所有数据类型的通用表示形式。`Lua` 是动态类型语言，变量本身没有类型，**值的类型是在运行时确定的**。为了高效地存储和管理这些值，`Lua` 使用 `TValue` 结构来**表示所有的值类型**。
- 在 Lua 的 `table` 实现中，`TValue` 是**存储键值对的基本单位**。无论是数组部分还是哈希表部分，`table` 中的**每个元素都是一个** `TValue`。
- **数组部分**
  - 数组部分是一个连续的 `TValue` 数组。
  - 每个 `TValue` 存储一个值，**键是隐式的**（**通过数组下标访问**）。
- **哈希表部分**
  - 哈希表部分是一个 `Node` 数组，每个 `Node` **包含一个键值对**。
  - 键和值都是 TValue 类型。
***
# 热更新原理是什么？
热更新的核心原理是通过**动态加载**和**替换代码**，在不重启应用程序的情况下实现更新。

- Lua 脚本是纯文本文件，无需编译，可以直接加载和执行。
- 在运行时，**通过 Lua 虚拟机动态加载新的 Lua 脚本**。
- 将新的 Lua 脚本加载到内存中，替换旧的逻辑。
- Lua 的全局环境和函数可以被动态覆盖，从而实现逻辑更新。

**面试时重点回答下面的**
- **加载机制**: lua通过`require`函数加载模块,然后将加载好的放入`package.loaded()`表中
- **卸载机制**: 将`package.loaded()`设置为**nil**,下次`require`函数会重新加载这个模块

```lua
-- 定义热更新函数，参数为模块名
function reloadUp(module_name)
  -- 从全局环境_G中获取旧的模块表
  local old_module = _G[module_name]
  -- 将package.loaded中对应模块标记为未加载，准备重新加载
  package.loaded[module_name] = nil
  -- 重新加载模块，实际上是执行了模块的文件，加载新的内容到内存
  require(module_name)
  -- 从全局环境_G中获取刚加载的新模块表
  local new_module = _G[module_name]
  -- 遍历新模块表中的所有字段
  for k, v in pairs(new_module) do
    -- 将新模块表中的字段复制到旧模块表中，实现更新
    old_module[k] = v
  end
  -- 将更新后的旧模块表重新放回package.loaded，表示模块已被加载
  package.loaded[module_name] = old_module
end
```
****
# lua显式传递和隐式传递
***
# lua元表是什么?
- Lua 中的**元表**是一种特殊的表，用于**定义或扩展其他表的行为**。通过元表，可以**为表添加自定义的操作逻辑**,定义原始值在特定操作下的行为
- 元表中的键是 Lua 预定义的事件名称，称为元方法
## 常见的元方法
- `__index`
  - 当**访问表中不存在的键**时触发,
- `__newindex`
  - 当**给表中不存在的键赋值**时触发。一旦有__newindex就不再执行最初的赋值操作,这就解决了lua新建值时提示错误的问题
  - 如果实在想赋值就用`rawset`,它可以绕过触发元方法
## 元表的实际应用
- 使用 `__index `实现继承。
***
# xlua是怎么减少C#脚本的开销的
主要方式是通过优化 Lua 与 C# 之间的交互机制，尽量减少频繁的跨语言调用和数据转换。
- 将多个 C# 调用**合并为一个批量调用**，减少跨语言调用的次数。
  - 将游戏逻辑的主要部分放在 Lua 脚本中，减少 Lua 调用 C# 的频率。
- xLua 使用**缓存机制**来**减少重复查找和调用的开销**。
  - 将 Lua 中频繁调用的 C# 方法或对象缓存起来，避免每次调用时都进行查找。
***
# lua是怎么控制角色控制、障碍物生成、碰撞检测的?
- 角色控制部分:
    - 通过`Rigidbody2D`组件实现物理运动,具体语句如下

    ```lua
    rb = self:GetComponent("Rigidbody2D");
    ```
  - 在update()中通过鼠标左键点击（Input.GetMouseButtonDown(0)）触发跳跃,在y轴给一个向上的力

    ```lua
    if CS.UnityEngine.Input.GetMouseButtonDown(0) and isJumping == false then
            rb.velocity = CS.UnityEngine.Vector2(0, 7);
    ```
- 障碍物生成
  - 这里其实我投巧了,我先是生成一个随机数(1-8),摇到哪个就实例化哪个预制体
    ```lua
    if chooseObstacle == 1 then
        CS.UnityEngine.Object.Instantiate(Obstacle1);
    ```

- 碰撞检测部分：
  - 通过onTriggerEnter2D函数处理2D触发器碰撞,参数为collision
  - 根据碰撞对象的标签（tag）进行不同处理：
    - "GameOver"标签：暂停游戏（Time.timeScale = 0）并显示游戏结束UI
    - "StarClam"标签：增加金钱数量并更新存储（PlayerPrefs）
***
# xlua与ulua或者tolua有哪些不同
- xLua：适合需要高性能、热更新和快速集成的项目，尤其是移动端游戏。
- uLua：适合对性能要求不高、需要快速上手的项目。
- ToLua：适合对性能有较高要求、需要深度定制的项目。