[toc]
****
# 协程跟线程的区别
- **线程**
    - **线程是进程内的一个执行单元，是操作系统调度的基本单位**。一个进程可以包含多个线程，线程共享进程的资源。**同步机制**
    - 切换：线程上下文切换比进程上下文切换要快得多。
    - **线程不拥有系统资源,但是可以访问隶属于进程的资源。**
    - 线程是被分割的CPU资源，协程是组织好的代码流程，线程是协程的资源。
    
- **协程**
  - 协程运行在**主线程**上，依赖于Unity的生命周期。
  - 协程是用户态的轻量级线程，**由程序自身调度**，而不是由操作系统调度。它是一种协作式并发模型。**异步机制**
  - **一个线程可以有多个协程，一个进程也可以有多个协程**。
  - **协程能保留上一次调用时的状态。**
  
- **进程(拓展)**
  - **进程是操作系统分配资源和调度的基本单位**，是程序运行时的实例。一个进程可以包含多个线程。**同步机制**
  - **进程是拥有资源的一个独立单位**
  - 创建或撤销进程时，**系统都要为之分配或回收系统资源**

****
# yield return 的条件是在什么时候判定的
这个问题是unity的,但是和上题相关性强
- 那么挂起的程序什么时候才执⾏？**协同程序主要是Update()⽅法之后，LateUpdate()⽅法之前调⽤的**。

- yield return 的条件判定时机主要取决于它返回的对象类型：
    - yield return null: 等待下一个Update()周期。
    - 由时间调度的,像yield return new WaitForSeconds(seconds): 受Time.timeScale影响
    - yield return StartCoroutine(anotherCoroutine)：等待嵌套协程完成。

****
# TCP和UDP
## TCP 和 UDP 的区别
- `TCP`**面向连接**（（如打电话要先拨号建立连接）;`UDP`是**无连接的**，即发送数据之前不需要建立连接。
- `TCP`**要求安全性**，提供**可靠**的服务，通过TCP连接传送的数据，不丢失、不重复、安全可靠。而`UDP`尽最大努力交付，即**不保证可靠交付**。
- `TCP`是点对点连接的，`UDP`一对一，一对多，多对多都可以
- `TCP`**传输效率相对较低**,而`UDP`**传输效率高**，它适用于对高速传输和实时性有较高的通信或广播通信。
- `TCP`适合用于网页，邮件等;`UDP`适合用于视频，语音广播等
- `TCP`面向**字节流**，`UDP`面向**报文**

## TCP和UDP的头部格式
- **TCP**
  ![alt text](\计网相关图片\image.png)
- **UDP**
  ![alt text](\计网相关图片\image1.png)

## UDP和TCP的共同之处
- 它们都提供**目的端口**和**源端口**
- 它们都提供**校验和**,但 UDP 的校验和是可选的，而 TCP 的校验和是强制的。
- UDP 和 TCP 都依赖于 **IP 协议**（如 IPv4 或 IPv6）来传输数据包
- 都支持**多路复用**和**多路分解**
  - `多路复用`：将多个应用的数据通过同一个传输层协议发送。
  - `多路分解`：将接收到的数据根据端口号分发给正确的应用程序。

## TCP

### 1.讲下TCP三次握手流程
- 开始客户端和服务器都处于`CLOSED`状态，然后服务端开始监听某个端口，进入`LISTEN`状态
- 第一次握手(SYN=1, seq=x)，**发送完毕后**，**客户端**进入 `SYN_SEND` 状态
- 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，**服务器端**进入 `SYN_RCVD` 状态。
- 第三次握手(ACK=1，ACKnum=y+1)，发送完毕后，**客户端**进入 `ESTABLISHED` 状态，当**服务器端接收到这个包**时,也进入 `ESTABLISHED` 状态，TCP 握手，即可以开始数据传输。

### 2.讲下TCP四次挥手过程
- 第一次挥手(FIN=1，seq=u)，发送完毕后，**客户端**进入`FIN_WAIT_1` 状态
- 第二次挥手(ACK=1，ack=u+1,seq =v)，发送完毕后，**服务器端**进入`CLOSE_WAIT` 状态，**客户端接收到这个确认包之后**，进入 `FIN_WAIT_2` 状态
- 第三次挥手(FIN=1，ACK1,seq=w,ack=u+1)，发送完毕后，**服务器端**`进入LAST_ACK` 状态，等待来自客户端的最后一个ACK。
- 第四次挥手(ACK=1，seq=u+1,ack=w+1)，**客户端**接收到来自服务器端的关闭请求，**发送一个确认包**，并进入 `TIME_WAIT`状态，**等待了某个固定时间(两个最大段生命周期，2MSL，2 Maximum Segment Lifetime)** 之后，**没有收到服务器端的 ACK**，**认为服务器端已经正常关闭连接**，于是**自己(客户端)也关闭连接**，进入 `CLOSED` 状态。**服务器端**接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。

### 3.TCP 是如何保证可靠性的
- 首先，TCP的**连接是基于三次握手**，而**断开则是四次挥手**。确保连接和断开的可靠性。
- 其次，TCP的可靠性，还体现在**有状态**;TCP会记录哪些数据发送了，哪些数据被接受了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。
- 再次，TCP的可靠性，还体现在**可控制**。它有报文校验、ACK应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。

### 4.TCP的拥塞控制
#### 四个常见算法
- **慢开始**
  - cwnd(窗口值)随轮次(RTT)以**指数形式增长**,到达ssthresh(门限值)后进入拥塞避免
- **拥塞避免**
  - 随着RTT轮次**逐渐加1**,直到发生**丢包**(RTO)
- **RTO超时重传**
  - 慢启动阀值sshthresh = cwnd /2
  - cwnd重置为1
  - 进入新的慢启动过程
- **快重传**
  - 快重传相较于RTO超时重传的处理方式要更好一些,但是**需要有3个重复ACK**
  - 拥塞窗口大小 cwnd = cwnd/2
  - 慢启动阀值 ssthresh = cwnd
  - 进入快速恢复算法
- **快恢复**
  - cwnd = cwnd /2
  - sshthresh = cwnd

*** 
# 帧同步和状态同步

## 1.帧同步
帧同步是指**客户端之间只同步用户的输入指令**，例如，向前走、按下哪些技能等，不同的客户端各自计算自己的结果。由于消耗的流量只取决于指令数，因此会大大减少消息。另外由于消息结构的原因，帧同步的速度要比状态同步更快，因此适用于一些高频交互的游戏。

不过由于每个客户端需要独立计算，因此需要保证计算结果的一致性。理论上讲，相同的时机，输入相同的内容，会得到相同的结果。不过从实际情况看，做到完全相同还是有些难度的。以Unity引擎为例，一方面，各个脚本之间Start、Update等生命周期函数的调用顺序不确定；另一方面，使用Physic物理系统也不保证是确定性模拟。比如一个单位的坐标偏差了0.01导致技能未能击中目标，那么这个目标的血量判断就会受到影响。如果这个目标的行为受到血量的影响，那么最终结果会完全不同。因此让每个客户端计算结果完全相同不是一件容易的事。一些常见的注意事项如下。
◎不使用浮点数，用整数代替。
◎不同客户的同步频率要保证一致。
◎随机种子相同，并自定义接口防止其他公用系统干扰。
◎使用排序容器，保证遍历顺序。
◎逻辑显示分离。
◎使用补间过渡，调整速率，掩盖卡顿。
除了一致性的难点，帧同步还需要解决流畅度的问题。由于通过网络传输过来的数据一定会慢于本地，而我们又希望在相同的时刻输入信息，因此就会引发等待，反映到用户体验就是不流畅。

优化方法有很多，例如，
- 在帧同步游戏中，由于广播的频率非常高，因此每次广播的数据就要足够小，这样可以节省很多消息处理的时间。
- 对于消息，可以将需要所有客户端同时发生的内容提前广播给其他用户，采用时钟同步。
- 客户端逻辑先行，显示通过平滑追赶的方式处理。很多改进是体验优化的范畴，需要结合具体游戏进行

在传输层，移动端的同步建议使用UDP作为传输协议。TCP为了保证传输的可信性，很多机制不太适合波动较大的移动网络。在弱网络环境下，UDP的RTT几乎不受影响，而TCP的RTT波动比较大，特别是在丢包重发时影响比较明显。虽然使用UDP会引入丢包、乱序的问题，但可以通过冗余的方式来解决这个问题。比如每帧三个数据包，实际上是包含了过去两帧的数据，也就是每次发三帧的数据来对抗丢包。
## 2.状态同步
本节中提到的状态同步和帧同步都是广义上的，虽然它们的底层实现都可以基于上面提到的模式，但从广义上讲，它们的同步思路不同。

状态同步指的是**将其他玩家的状态行为同步**，例如，怪物的AI控制、角色技能释放、战斗伤害计算等。纯粹的状态同步模式下，这些内容都由**服务器**运算，只是将结果下发给客户端，客户端根据得到的数据驱动显示即可。这种模式的缺点是流量消耗比较大，消耗的流量取决于场景中需要转发数据的人数和内容。另外，先天的结构导致响应速度存在问题，无法做到高频交互的顺畅体验。最明显的特点就是“拉扯”现象。它表现为某个角色会突然出现在某个位置，或某个技能效果突然出现，甚至角色忽然死亡等。引发这个现象的原因是，网络波动导致数据未能及时送达，而客户端进行了某些程度的预表现或航位推测。

对于大多数实时性要求不高、交互简单的游戏，一般会使用状态同步。通常来说，常规MMO类型的游戏只能使用状态同步。

