[toc]
***
# 1.面向对象
- 封装: 用程序语言来形容对象
- 继承: 复用封装对象的代码
- 多态: 同样行为的不同表现
***
# 2.封装
声明在namespace作用域中
***
## 2.1类声明的语法
```Csharp
class 类名
{
    //特征--成员变量
    //行为--成员方法
    //保护特征--成员属性

    //构造函数和析构函数
    //索引器
    //运算符重载
    //静态成员
}
```
***
## 2.2成员变量
**在类中是可以声明的变量类型为自己的类名的,和struct也正好相反**

- 为什么?
  - 类的实例通过new关键字在堆上创建，创建时会触发构造函数执行。反面就是不new就不构造,那也就是说内存时有限的
  - 再考虑类型,类是引用类型,结构体是值类型,那考虑`Person p;`这句代码,p就是一个引用,引用的内存是固定的,实例分配到堆上,那么你没赋值也就没构造
    ```Csharp
    public class Person{ Person p; }
    ```
  - 结构体是值类型，它的实例通常分配在栈上,而编译器需要为每个结构体类型计算一个确定的大小。
    ```Csharp
    public struct Person{ Person p; }
    ```
  - 这会产生一个递归的、无限大小的类型定义
  - 编译器无法计算出这个结构体到底需要多少字节的内存，因此会报错

**在类中是可以初始化变量的,这和struct正好相反**

- 为什么?
  - 类的实例在堆上分配，编译器会确保所有这些初始化代码被插入到每个构造函数的最开始处, 初始化发生在对象构造时，有明确的生命周期控制
  - 结构体经常在栈上分配，没有明确的构造时机,结构体必须保证即使没有调用构造函数，所有字段也有默认值（0或null）,编译器会自动为所有字段赋默认值,但是有不能显式初始化,这样就会造成歧义

OK,看完上面两条,相信你可能有疑问: 那我初始化类型为自己的类名的变量,类里面不就跟struct一样有递归了吗?

你说的对,所以又引入一个新知识点: **对于成员变量类型是自己的类时是不能对其进行初始化的**,虽然不会报错,但是这个操作是危险的,所以上面的理论都是基于这一点来说的(我是不是应该把这条写到上面?)

```Csharp
public class Person
{ 
    Person p = new Person(); // 这个是不行的
    Person p = null; //这个是可以的
}
```

### 补充:
  - 类中声明自身类型成员时，虽然语法允许，但实际使用时需避免 “无限递归实例化”（如 Person p = new Person()），否则会导致栈溢出（StackOverflowException）。而 Person p = null 是安全的，因为它只是一个未指向任何对象的引用。
  - 结构体的构造函数必须显式初始化所有成员，这是为了保证值类型的确定性 —— 无论通过哪种方式创建结构体，其成员都有明确的值，避免未定义行为。说人话就是,结构体里的成员变量不能初始化赋值,但是在结构体里的构造函数你要赋值就必须把所有的成员变量都给赋值了
***
## 2.3成员变量的初始值
- 值类型: 默认值是0
- 引用类型: 默认值是null
- defult(变量类型) 就能得到类型的默认值
***
## 2.4访问修饰符
- public: 公共的
- private: 私有的  允许内部访问
- protect: 受保护的  运行内部和子类访问
***
## 2.5成员方法
- 成员方法目前不加static,到static知识点的时候具体分析
- 成员方法必须实例化出对象,再通过对象来使用
- 成员方法受访问修饰符影响
***
## 2.6默认访问级别
- 类的成员：默认是 private
- 结构体的成员：默认是 private
- 类本身和结构体本身：默认是 internal

internal，意思是"在同一程序集内可访问"。
在类和结构体内部，字段、方法、属性等成员默认都是 private

在类和结构体前加上public或private，不会直接影响其内部成员的访问级别，但它会控制"谁能看到这个类"，从而间接影响成员的可访问性。

一个项目 == 一个程序集 , 每个.csproj文件(打开你项目所在的文件夹就知道了)编译后就是一个程序集。同一项目内的代码都在同一程序集中，可以互相访问internal成员。不同项目之间需要添加引用才能访问public成员。

***
## 2.7构造函数,析构函数,GC
### 构造函数
在实例化对象时,会调用构造函数用于初始化
如果不写,默认存在一个无参的构造函数

- 没有返回值
- 函数名和类名相同
- 没有特殊需求时,一般是public
- 构造函数可以被重载
- 如果不自己实现无参的构造函数而实现了有参构造的函数,就会失去默认的无参构造函数

**类中是允许声明无参构造函数的,而结构体不允许**

#### 构造函数的特殊写法
`构造函数名(参数列表) : this(参数1,参数2,...)`
```Csharp
class Student
{
    string name;
    int age;

    public Student()
    {
        name = "Cherno";
        age = 10;
    }

    public Student(int age)
    {
        this.age = age;
    }

    public Student(string name, int age) : this() //先调用public Student()
    { 
    }

    public Student(string name, int age) : this(age) // 先调用public Student(int age)
    { 
    }
}
```
- 这样写会调用后面的构造函数,再调用当前的构造函数

### 析构函数
对于像C++这样需要手动管理内存的语言,需要在析构函数中做一些内存回收处理
但是C#存在GC,几乎不怎么使用析构

### GC
垃圾回收的过程是在遍历堆(Heap)上的动态分配的所有对象
通过识别它们是否被引用来确定哪些对象是垃圾,哪些对象仍要被使用
所谓垃圾就是没有被任何变量,对象引用的内容, 垃圾就需要被回收释放

GC有很多算法
- 引用计数
- 标记清除
- 标记整理
- 复制集合

GC只负责堆内存的垃圾回收
引用类型都是存在堆中的,所以它的分配和释放都是通过垃圾回收机制来管理的

栈上的内存是由系统自动管理的
值类型在栈中分配内存,它们有自己的生命周期,不用对它们进行管理,会自动分配和释放

#### C#的GC
- 首先会将堆内存分成三代(0代,1代,2代)
  - 代是垃圾回收机制的一种算法
- 新分配的对象会被配置到第0代内存中
- 每次分配都可能会进行垃圾回收以释放内存
</br>

- 在一次内存回收过程开始时,垃圾回收器会认为堆中全是垃圾,会进行以下两步:
  1. 标记对象: 从根(静态字段,方法参数)开始检查引用对象,标记后变为可达对象,未标记的为不可达
  2. 搬迁对象压缩堆: (挂起执行托管代码线程) 释放未标记对象,搬迁可达对象,修改引用地址
</br>

- 内存较大的对象总被认为是第二代内存,目的是减少性能损耗
- 不会对大对象进行搬迁压缩,83kb以上的对象被认为是大对象
</br>

- 当前代内存满时会触发GC,释放当前代及处于其下的代的内存
- 说人话就是:
  - 0代满了,释放0代内存, 并使可达对象升代
  - 1代满了,释放0代和1代内存, 并使可达对象升代(原本0代可达的到1代,原本1代可达的到2代)
  - 2代满了,释放0代,1代和2代的内存,该升代的升代,该保留的保留(原本2代的可达保留在2代,原本1代的可达升至2代,原本0代的升至1代)
</br>

- 了解了GC机制后,就易明白
  - 0代内存释放的频率最高,1代次之,2代最低
  - 2代内存很大,用于存放所以经过分代淘汰的所筛选下来的可达对象 
  - 大对象每次释放消耗的内存较大,每次释放都会消耗CPU,使性能降低

手动触发GC的方式: `GC.Collect();`
但是GC是很耗性能的
***
## 2.8成员属性
### 概念
- 用于保护成员变量
- 为成员属性的获取和赋值添加逻辑处理
- 属性可以让成员变量在外部((只能获取不能修改) || (只能修改不能获取))
- 属性命名一般使用帕斯卡命名

### 语法
```Csharp
访问修饰符 属性类型 属性名
{
    get{}
    set{}
}
```
- `value`关键字(仅限在set作用域中), 用于表示外部传入的值,所以`value`的类型肯定是和属性类型一致

### get和set前可以加访问修饰符
- 不加,默认使用属性声明时的访问修饰符
- 加的访问修饰符要低于属性的访问权限
- 不能让get和set的访问权限都低于属性的权限 
- get和set可以只有一个,那就没必要在前面加访问修饰符了

### 自动属性
- 作用: 如果类中有一个特征是希望外部能得不能改,并且没有什么特殊处理,那么可以直接使用自动属性
```Csharp
public string name{get; private set;}
```
***
## 2.9索引器
### 作用
让对象可以像数组一样通过索引访问其中元素,使程序看起来更直观,更容易编写

### 语法
```csharp
访问修饰符 返回值 this[参数类型 参数名,参数类型 参数名...]
{
    get{}
    set{}
}
```
- 上面的例子不直观,看下面的
```Csharp
class Person
{
    string name;
    int age;
    Person[] friends;

    public Person this[int index]
    {
        get 
        {
            return friends[index];
        }
        set 
        {
            friends[index] = value;
        }
    }
}

static void Main(string[] args)
{
    Person p = new Person();
    p[0] = new Person();
}
```
- 以上解决了什么问题呢? 思考一下,如果没有定义索引器
- 那你访问friends中的元素,要么把friends用属性给包裹起来,要么加上public
- 再进一步想,这个代码中的get中index如果非法不就报错了吗? 所以索引器中也是可以去组织自己的逻辑的(set也同理),比如写成这样
```csharp
get
{
    if(friends == null || friends.Length - 1 < index)
        return null;
    return friends[index];
}
```
### 索引器重载
```csharp
class Person
{
    string name;
    int age;
    Person[] friends;
    int[,] array;

    public int this[int i, int j]
    {
        get { return array[i, j];}
        set { array[i, j] = value;}
    }

    public Person this[int index]
    {
        get { return friends[index];}
        set { friends[index] = value;}
    }
} 
```
***
## 2.10静态成员
静态成员的特点: 直接用类名点出来直接使用

静态成员大部分是公共的

```csharp
public class Test
{
    static public float PI = 3.1415926f;
    public int testInt = 5;

    static public float CalcuCircie(float r){return PI * r * r;}
    public void TestFun(){Console.WriteLine("Test");}
}

static void Main(string[] args)
{
    Console.WriteLine(Test.PI);
    Console.WriteLine(Test.CalcuCircie(2));

    Test t = new Test();
    Console.WriteLine(t.testInt);
    t.TestFun();
}

```
根据以上代码可以发现,静态的成员变量或成员函数不用实例化就能调用,而非静态的需要实例化

### 为什么可以直接使用
- 程序在开始进行时,就会分配内存空间
- 静态成员的生命周期和程序一致,也就是程序开始运行到程序结束
- 因此,静态成员就会有一个唯一的内存空间来存储,进而让静态成员有了唯一性
- 只要静态成员是公共的,那它也就有全局性
</br>

### 静态与非静态
1. 非静态成员变量与静态函数的生命周期不一致
2. 非静态成员变量只能将对象实例化出来后才能使用
3. 静态方法中不能直接访问实例成员，因为不知道要操作哪个对象

根据以上三条可知,静态函数中不能使用非静态成员,如果非要使用,就只能先实例化对象后再用,如下
```CSharp
public class Test
{
    static public float PI = 3.1415926f;
    public int testInt = 5;

    static public float CalcuCircie(float r)
    {
        Test t = new Test();
        t.testInt = 20;

        return PI * r * r;
    }
}
```
所以理解上面后,下面这句话也就好理解了
- 非静态函数可以使用静态成员

### 作用
1. 常用的唯一变量的声明
2. 方便快速的获取对象声明

### const和static
- 常量初始化必须赋值,静态变量不用
- 常量不能后期修改,静态变量可以
- const只能修饰变量
- const一定是写在访问修饰符后面的
- 它们都可以通过类名点出来用

const(常量)可以理解为特殊的static(静态)(只是"理解为",可不是等同)

### 简单单例实现
- 以下不是单例的实现,但思路接近了
- 一个类对象,在整个应用程序的成名周期中,有且仅有一个该对象的存在,不能在外部实例化,直接通过该类类名就能够得到唯一的对象
```CSharp
//简单基本单例
namespace _5静态成员
{
    class Object
    {
        private static Object obj = new Object(); 
        public int testInt  = 20;
        public static Object Obj
        {
            get
            {
                return obj;
            }
        }

        private Object() { }
    }

    internal class Class2
    {
        static void Main(string[] args)
        {
            Console.WriteLine(Object.Obj.testInt);
        }
    }
}
```
***
## 2.11静态类和静态构造函数

### 静态类
- 只能包含静态成员
- 不能实例化

#### 作用
1. 将常用的静态成员写在静态类中,方便使用
2. 静态类不能实例化,更能体现工具类的唯一性,比如: Console就是一个静态类

一般情况下静态类里的成员或者方法都是公共的,除非要在类里面去实现或处理一些逻辑

### 静态构造函数
- 静态类和普通类都可以有
- 不能使用访问修饰符
- 不能有参数
- 不管是在静态类中还是在非静态类中,当你第一次使用了类中的内容时,就会自动调用一次,且只会调用一次

#### 作用
在静态构造函数中初始化静态变量

## 2.11拓展方法
### 概念
为现有的**非静态变量类型**添加新方法

### 作用
1. 不需要在对象中重新写方法
2. 不需要继承来添加方法
3. 为别人封装的类型写额外的方法

### 特点
1. **一定是写在静态类中**
2. **一定是静态函数**
3. 第一个参数为拓展目标
4. 第一个参数用this修饰
5. 拓展方法与原方法重名的话,优先调用原方法,拓展方法就没有用了

### 语法
```CSharp
访问修饰符 static 返回值 函数名(this 拓展类名 参数名,参数类型 参数名,参数类型 参数名...)
```

```CSharp
namespace _7拓展方法
{
    class Ticktet
    {
        public int num1 { get; set; }
        public int num2 { get; set; }

    }

    static class Expend
    {
        public static int Add(this Ticktet t, int a, int b)
        {
            t.num1 = a;
            t.num2 = b;
            return t.num1 + t.num2;
        }
    }

    internal class Class1
    {
        static void Main(string[] args)
        {
            Ticktet t = new Ticktet();
            Console.WriteLine(t.Add(3,5)); //在原来的类的基础,在外部拓展了方法
            Console.WriteLine(Expend.Add(t,4,5));
        }
    }
}
```
***
## 2.12重载运算符
### 特点
1. 一定是一个**公共的静态方法**
2. 返回值写在operator前
3. 逻辑处理自定义

### 作用
让自定义类和结构体对象可以进行运算

!!! important 注意
    1. 条件运算符需要成对实现
    2. 一个符号可以多个重载
    3. **不能使用ref和out**
    4. 参数列表中必须至少一个当前类类型的参数

### 语法
```CSharp
public static 返回类型 operator 运算符(参数列表)
```
```CSharp
struct Vector2
{
    public int x; 
    public int y;

    public static Vector2 operator +(Vector2 v1,Vector2 v2)
    {
        Vector2 v = new Vector2();
        v.x = v1.x + v2.x;
        v.y = v2.y + v2.y;
        return v;
    }
}
```
### 可重载和不可重载的运算符
- 条件运算符,比如`>`和`<`,`<=`和`>=`等,必须配对实现;就比如说你重载了`>`,你就必须同时重载`<`,不然就报错
- 逻辑或`&&` 逻辑或`||`,索引符`[]`,强转运算符`()`,特殊运算符,三目运算符等都不能重载
***
## 2.13内部类和分部类

### 内部类
在一个类中再声明一个类

- 使用时要用包裹者点出自己
- 访问修饰符的作用很大

### 分部类
把一个类分成几部分声明

!!! important 注意
    - 关键字为**partial**
    - 分部描述一个类,提高程序的拓展性
    - 分部类可以写在多个脚本文件中
    - 分部类的访问修饰符要一致
    - 分部类中不能有重复成员


### 分部方法
将方法的声明和实现分离

**特点**
- 不能加访问修饰符,默认私有
- 只能在分部类中声明
- 返回值只能是void
- 可以有参数,但是不能用out关键字 
***
# 3.继承
- 一个类A继承一个类B, 类A将会继承类B的所有成员, A类将拥有B类的所有特征和行为
- 子类可以有自己的特征和行为
- 单根性: 子类只能有一个父类
- 传递性: 子类可以间接继承父类的父类

***
## 3.1继承的基本语法
```CSharp
class 类名 : 被继承的类名{  }
```
!!! important 子类和父类符同名成员
    C#中允许子类存在和父类同名的成员, 但是不建议使用
***
## 3.2里氏替换原则
任何父类出现的地方,子类都可以替代

!!!important 重点
    父类容器装子类对象,因为子类对象包含了父类的所有内容

**作用:**
方便进行对象的存储和管理

```CSharp
class GameObject { }

class Player:GameObject
{
    public void PlayerAtk() { Console.WriteLine("Player攻击!"); }
}
class Monster:GameObject
{
    public void MonsterAtk() { Console.WriteLine("Monster攻击!"); }
}

internal class Class1
{
    static void Main(string[] args)
    {
        //里氏替换原则
        GameObject player = new Player();
        GameObject monster = new Monster();
    }
}
```
根据以上代码你会发现,`player`的容器是`GameObject`(父类),`player`是`Player`(子类)对象,照理说`player`是拥有`PlayerAtk()`这个方法的,但是当你写
```CSharp
player.PlayerAtk();
```
这句代码时,你会发现是报错的,解决方法看下面

### is和as
`is`: 判断一个对象是否是指定的类对象,返回值为bool类型
`as`: 将一个对象转换为指定类对象,返回值为指定类型对象,返回失败时为null

```CSharp
类对象 is 类名
类对象 as 类名
```
回到上面的报错,解决方法为
```CSharp
if(player is Player)
{
    (player as Player).PlayerAtk();
}
```
此时就调用成功了

至此,里氏替换原则就差不多了,学完感觉挺鸡肋啊
其实它的主要使用场景如下:
```CSharp
class GameObject { }

class Player:GameObject
{
    public void PlayerAtk() { Console.WriteLine("Player攻击!"); }
}
class Monster:GameObject
{
    public void MonsterAtk() { Console.WriteLine("Monster攻击!"); }
}

internal class Class1
{
    static void Main(string[] args)
    {
        //假设有一个GameObject数组,你不能清楚的知道里面的每一个元素的类型
        GameObject[] objects = { new Player(), new Monster(), new Player() };//这里明确定义了元素是为了偷懒,明白意思就行

        for (int i = 0; i < objects.Length; ++i)
        {
            if (objects[i] is Player)
            {
                //这里就可以写Player的逻辑
            }
            else if (objects[i] is Monster)
            {
                //这里就可以写Monster的逻辑
            }
        }
    }
}
```
**再来个具体的场景吧**
在游戏中有一个场景里又有玩家又有怪物还有NPC,但是它们的基类都是一样的,如果你想一下管理上面所有类型的对象,你完全可以用它们公共的基类容器去存储这个场景里所有的对象,然后通过is和as来决定它们各自需要处理的逻辑

***
## 3.3继承中的构造函数
**特点**
- 当声明一个子类对象时,先执行父类的构造函数再执行子类的构造函数
- 父类的无参构造很重要
- 子类可以通过Base关键字 代表父类 调用父类构造

```CSharp
 class GameObject
 {
     public GameObject()
     {
         Console.WriteLine("GameObject构造");
     }
 }
 class Player : GameObject
 {
     public Player()
     {
         Console.WriteLine("Player构造");
     }
 }
 class MainPlayer : Player
 {
     public MainPlayer()
     {
         Console.WriteLine("MainPlayer构造");
     }
 }

 internal class Class1
 {
     static void Main(string[] args)
     {
         MainPlayer mainPlayer = new MainPlayer();
     }
 }
```
- 输出为
```CSharp
GameObject构造
Player构造
MainPlayer构造
```
### 父类无参构造的重要性
在实例化子类对象时,默认会调用父类的无参构造函数,而当你在父类中没有实现无参构造,且实现了有参构造时,无参构造函数就会失效,此时子类在继承时就会报错

那如果我想让子类在实例化时调用你指定的父类中的构造函数(不管是有参的还是无参的),看下面

### base关键字
- 和this在构造函数上的用法相似
- 可以指定父类中的构造函数
- 子类构造函数, 你不管是直接还是间接,是默认还是指定,都需要有相关联的父类构造函数
```CSharp
class Father
{
    public Father(int i)
    {
        Console.WriteLine("父类有参构造");
    }
}
class Son : Father
{
    public Son(int i) : base(i) // 这里指定的就是父类的public Father(int i)构造函数
    {
        Console.WriteLine("子类有参构造");
    }

    public Son(int i, string str) : this(i) //间接调用父类构造
    { 
    }
}
```
***
## 3.4object和拆装箱
### 所有类型的最终基类
- 关键字: `object`
- `object`是所有类型的基类,它是一个类(引用类型)
- 可以利用里氏替换原则,用object容器装所有对象
- 可以用来表示不确定的类型,作为函数参数类型
</br>

```CSharp
class Base{ public void Fun() { } }

internal class Class1
{
    static void Main(string[] args)
    {
        //引用类型及其转换
        object o = new Base();
        if (o is Base)
            (o as Base).Fun();

        //值类型及其转换
        object o1 = 1f;
        float f = (float)o1;

        //string类型
        object o2 = "123";
        string str = o2.ToString();
        string str1 = o2 as string;//推荐

        //数组
        object o3 = new int[10];
        int[] arr1 = (int[])o3;
        int[] arr2 = o3 as int[];//推荐
    }
}
```
- 为什么推荐? 因为好记: 值类型就括号强转,引用类型就用`as`
### 装箱和拆箱
**发生的条件**
- 用object存值类型(装箱)
- 用object存引用类型(拆箱)

**装箱**
把值类型存储在引用类型中,栈内存会迁移到堆内存

**拆箱**
把引用类型存储的值类型取出来,堆内存会迁移到栈内存

**优缺点**
- 不确定类型时可以方便参数的存储和传递
- 内存迁移,性能消耗大

**看下面的例子**
- 上面说的方便在哪? 看下面代码中的`TestFun`函数
- 是个东西就能往里传, 你就说方不方便吧? 
```CSharp
class Base{ public void Fun() { } }

internal class Class1
{
    static void Main(string[] args)
    {
        //装箱
        object o = 3;
        //拆箱
        int num = (int)o;

        TestFun(1243,63f,0.2343,"Cherno",' ',new Base());
    }
    static void TestFun(params object[] objects)
    {
        //用上面的方法区别值类型和引用类型,然后执行对应的逻辑
    }
}
```
***


